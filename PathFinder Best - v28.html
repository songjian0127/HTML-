<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FibreNet Pro - Enterprise V15 (Deep Diversity)</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>
    
    <script>
        tailwind.config = { 
            darkMode: 'class', 
            theme: { 
                extend: { 
                    fontFamily: { sans: ['Inter','sans-serif'], mono: ['Fira Code','monospace'] },
                    colors: {
                        brand: { 50: '#eff6ff', 100: '#dbeafe', 500: '#3b82f6', 600: '#2563eb', 700: '#1d4ed8', 800: '#1e40af', 900: '#1e3a8a' }
                    },
                    animation: {
                        'fade-in': 'fadeIn 0.3s ease-out',
                        'slide-in': 'slideIn 0.3s ease-out'
                    },
                    keyframes: {
                        fadeIn: { '0%': { opacity: '0' }, '100%': { opacity: '1' } },
                        slideIn: { '0%': { transform: 'translateY(-10px)', opacity: '0' }, '100%': { transform: 'translateY(0)', opacity: '1' } }
                    },
                    // [NEW] Add custom transition property for the shine effect
                    transitionProperty: {
                        'bg-pos': 'background-position',
                    }
                } 
            } 
        }
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Fira+Code:wght@400&display=swap');
        body { font-family: 'Inter', sans-serif; }
        
        ::-webkit-scrollbar { width: 6px; height: 6px; } 
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #94a3b8; }
        .dark ::-webkit-scrollbar-thumb { background: #475569; }
        
        .leaflet-popup-content-wrapper { padding: 0; border-radius: 12px; overflow: hidden; box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1), 0 8px 10px -6px rgba(0, 0, 0, 0.1); }
        .leaflet-popup-content { margin: 0; width: 280px !important; }
        .leaflet-container a.leaflet-popup-close-button { top: 8px; right: 8px; color: #64748b; font-size: 16px; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; border-radius: 50%; background: rgba(255,255,255,0.8); z-index: 10; }
        .leaflet-container a.leaflet-popup-close-button:hover { background: #f1f5f9; color: #ef4444; }

        .sidebar-card { @apply bg-white dark:bg-slate-900 rounded-lg border border-slate-200 dark:border-slate-800 mb-3 overflow-hidden shadow-sm; }
        .sidebar-header { @apply px-4 py-2.5 border-b border-slate-100 dark:border-slate-800 flex items-center gap-2 bg-slate-50/50 dark:bg-slate-900; }
        .sidebar-body { @apply p-3; }

        .btn-primary { @apply w-full bg-brand-600 hover:bg-brand-700 text-white font-semibold py-2.5 px-4 rounded-lg text-xs shadow-sm hover:shadow transition-all flex items-center justify-center gap-2; }
        .btn-danger { @apply bg-white dark:bg-slate-800 hover:bg-red-50 text-red-500 border border-slate-200 dark:border-slate-700 font-bold py-2 px-3 rounded-lg text-xs shadow-sm transition-colors; }

        #map-container { position: relative; flex: 1; min-height: 0; overflow: hidden; }
        #map { position: absolute; top: 0; bottom: 0; left: 0; right: 0; z-index: 0; background: #e2e8f0; } 
        .dark #map { background: #0f172a; }
        
        /* Updated Option UI */
        /*
        |--------------------------------------------------------------------------
        | Option Card Button Styles
        |--------------------------------------------------------------------------
        |
        | Includes base styles, border, padding, hover, and active states.
        |
        */

        /* Solution cards â€“ soft bordered tiles with subtle hover/active states */
        .option-card-btn{
            @apply w-full text-left 
                px-3 py-2               /* Padding inside button */
                rounded-xl 
                border border-slate-300; /* Base border color and presence */
            
            @apply bg-white dark:bg-slate-900/70
                text-slate-600 dark:text-slate-300 
                shadow-sm 
                flex flex-col gap-1 mb-1
                relative overflow-hidden 
                transition-all;
        }

        /* Small meta badge inside cards (unchanged behaviour) */
        .option-card-btn .option-badge{
            @apply text-[9px] px-1.5 py-0.5 rounded-xl 
                border border-slate-200/70
                bg-slate-50/80 dark:bg-slate-800/60 dark:border-slate-700/80
                text-slate-500 dark:text-slate-400;
        }

        /* Hover state: subtle background change */
        .option-card-btn:hover {
            @apply bg-slate-100 dark:bg-slate-800/80;
        }

        /* Active/Selected state: Blue border highlight and pulsing effect */
        .option-card-btn.active {
            /* Applying the strong visual highlight for the selected state */
            @apply bg-blue-50 dark:bg-blue-900/40 
                border-blue-500          /* Highlight border color */
                shadow-lg;               /* Stronger shadow */
            
            /* Animation for the active state */
            animation: solutionPulse 0.7s ease-in-out infinite alternate;
        }

        /* Ensure the border color is explicitly set for the blue highlight */
        /* This is an override for non-Tailwind contexts but good for clarity */
        .option-card-btn.active {
            border-color: #3b82f6; /* Manually defined color for blue-500 */
        }


        /* Error state still stands out in red */
        .option-card-btn.error{
            @apply border-red-300 bg-red-50/80 dark:bg-red-900/40
                text-red-700 dark:text-red-200;
        }
        .option-badge {
            @apply text-[9px] uppercase font-bold px-1.5 py-0.5 rounded ml-auto;
        }

        /* Custom styling for the sliding shine effect on the Pathfinder button */
        .btn-shine-pathfinder {
            /* Define the gradient: Brand 600 -> Brand 500 (highlight) -> Brand 600 */
            background-image: linear-gradient(
                90deg, 
                #2563eb 0%,  
                #3b82f6 20%, 
                #2563eb 40%  
            );
            background-size: 250% auto; /* Make it wider than the button for the slide */
            color: white; /* Ensure text is visible */
        }

        /* Transitioning background-position creates the 'shine' movement */
        .btn-shine-pathfinder:hover {
            background-position: -150% 0; /* Slide the highlight across */
        }

        .path-btn { @apply bg-white dark:bg-slate-800 text-slate-600 dark:text-slate-300 border border-slate-200 dark:border-slate-700 hover:bg-slate-50 dark:hover:bg-slate-700 shadow-sm; }
        .path-btn.active { @apply bg-brand-600 text-white shadow-md border-brand-700 ring-2 ring-offset-1 ring-brand-500; }

        .endpoint-label { background: transparent; border: none; box-shadow: none; font-weight: bold; font-size: 11px; text-shadow: -1px -1px 0 #fff, 1px -1px 0 #fff, -1px 1px 0 #fff, 1px 1px 0 #fff; color: #1e40af; }
        .dark .endpoint-label { text-shadow: -1px -1px 0 #0f172a, 1px -1px 0 #0f172a, -1px 1px 0 #0f172a, 1px 1px 0 #0f172a; color: #60a5fa; }

        /* Resizers */
        .resizer-h { width: 5px; cursor: col-resize; background: transparent; position: absolute; right: 0; top: 0; bottom: 0; z-index: 50; transition: background 0.2s; }
        .resizer-h:hover, .resizer-h.active { background: #3b82f6; opacity: 0.5; }

        .resizer-v { height: 5px; cursor: row-resize; background: #f1f5f9; dark:background: #1e293b; width: 100%; border-top: 1px solid #e2e8f0; border-bottom: 1px solid #e2e8f0; flex-shrink: 0; transition: all 0.2s; display: flex; align-items: center; justify-content: center; }
        .dark .resizer-v { background: #0f172a; border-color: #1e293b; }
        .resizer-v:hover, .resizer-v.active { background: #cbd5e1; dark:background: #334155; }
        .resizer-v::after { content: ''; width: 30px; height: 3px; background: #cbd5e1; border-radius: 2px; }

        .broken-leg-dash { stroke-dasharray: 8, 8; animation: dash 1s linear infinite; }
        @keyframes dash { to { stroke-dashoffset: -16; } }

        /* Tier Tags */
        .tier-tag { @apply text-[9px] font-bold uppercase px-1.5 py-0.5 rounded ml-2 inline-block; }
        .tier-gold { @apply bg-amber-100 text-amber-700 border border-amber-200; }
        .tier-silver { @apply bg-slate-100 text-slate-600 border border-slate-200; }
        .tier-bronze { @apply bg-orange-50 text-orange-600 border border-orange-200; }
        .tier-fail { @apply bg-red-50 text-red-600 border border-red-200; }

        /* --- Modern Pathfinder UI Overrides --- */

        /* Smooth Accordion Animations */
        details > summary { list-style: none; }
        details > summary::-webkit-details-marker { display: none; }
        details[open] summary ~ * { animation: slideDown 0.3s ease-in-out; }

        @keyframes slideDown {
            0% { opacity: 0; transform: translateY(-10px); }
            100% { opacity: 1; transform: translateY(0); }
        }

        /* Timeline / Journey Visuals */
        .journey-line-container { position: relative; }
        .journey-line { 
            position: absolute; 
            left: 24px; 
            top: 36px; 
            bottom: 36px; 
            width: 2px; 
            background: linear-gradient(to bottom, #10b981 0%, #cbd5e1 50%, #ef4444 100%); 
            z-index: 0; 
        }
        .dark .journey-line { background: linear-gradient(to bottom, #10b981 0%, #334155 50%, #ef4444 100%); }

        /* Glassy Inputs */
        .glass-input-group {
            @apply relative bg-white dark:bg-slate-800/50 border border-slate-200 dark:border-slate-700 
            rounded-xl shadow-sm transition-all duration-200 hover:shadow-md focus-within:ring-2 
            focus-within:ring-brand-500/20 focus-within:border-brand-500 focus-within:bg-white dark:focus-within:bg-slate-800;
        }

        /* Custom Segmented Control */
        .segment-control {
            @apply flex p-1 bg-slate-100 dark:bg-slate-800 rounded-lg relative;
        }
        /* Styling for Mode Buttons */
        .segment-btn { @apply outline-none focus:ring-2 focus:ring-offset-1 focus:ring-brand-500/20 dark:focus:ring-offset-slate-900; }
        .segment-btn.active { @apply ring-2 ring-brand-500/50 ring-offset-1 dark:ring-offset-slate-900; }
        #seg-single.active { @apply border-brand-500 bg-brand-50 dark:bg-brand-900/20; }
        #seg-diverse.active { @apply border-emerald-500 bg-emerald-50 dark:bg-emerald-900/20; }
        #seg-ring.active { @apply border-purple-500 bg-purple-50 dark:bg-purple-900/20; }

        /* === Floating Label Input Styles === */
        .float-label-group {
            position: relative;
        }

        .float-label {
            transition: all 0.2s ease;
            cursor: text;
            pointer-events: none;
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            left: 0.875rem; /* px-3.5 */
            font-size: 0.75rem; /* text-xs */
            color: #9ca3af; /* text-gray-400 */
        }

        input.peer:focus ~ .float-label,
        input.peer:not(:placeholder-shown) ~ .float-label {
            top: 0.4rem;
            font-size: 0.65rem;
            color: #6366f1; /* indigo-500 */
        }

        /* --- GUIDE TOUR STYLES --- */
        /* Find #tour-spotlight and #tour-tooltip in your <style> and update durations */
        #tour-spotlight {
            box-shadow: 0 0 0 9999px rgba(15, 23, 42, 0.75); 
            /* CHANGED: 0.5s -> 0.4s */
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        #tour-tooltip {
            /* CHANGED: 0.5s -> 0.4s */
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 5010; 
        }
    </style>
</head>
<body class="bg-slate-50 dark:bg-slate-950 text-slate-900 dark:text-slate-200 h-screen flex flex-col overflow-hidden">
    <div id="tour-spotlight" class="fixed z-[5000] border-4 border-blue-500 rounded-xl pointer-events-none transition-all duration-500 ease-in-out opacity-0 hidden"></div>
    <div id="loadingOverlay" class="fixed inset-0 z-[2000] bg-slate-900/60 backdrop-blur-sm flex items-center justify-center hidden">
        <div class="bg-white dark:bg-slate-900 p-8 rounded-2xl shadow-2xl border border-slate-200 dark:border-slate-800 flex flex-col items-center gap-4 w-72">
            <div class="relative">
                <div class="absolute inset-0 bg-brand-500 rounded-full blur opacity-20 animate-pulse"></div>
                <i class="fa-solid fa-circle-notch fa-spin text-4xl text-brand-600 relative z-10"></i>
            </div>
            <div class="text-center">
                <div class="text-sm font-bold text-slate-800 dark:text-white mb-1" id="loadingTitle">Processing Data...</div>
                <div class="text-xs text-slate-500" id="loadingSubtitle">Optimizing diverse routes...</div>
                <div id="searchTimer" class="text-[10px] font-mono font-bold text-brand-600 mt-2 bg-brand-50 dark:bg-brand-900/30 px-2 py-0.5 rounded-full inline-block">0.00s</div>
            </div>
            <div class="w-full bg-slate-100 dark:bg-slate-800 rounded-full h-1.5 overflow-hidden hidden" id="progressContainer">
                <div id="progressBar" class="bg-brand-600 h-full transition-all duration-300" style="width: 0%"></div>
            </div>
        </div>
    </div>

    <!-- Debug Report Modal -->
    <div id="debugModal" class="fixed inset-0 z-[2200] bg-slate-900/80 backdrop-blur-sm flex items-center justify-center hidden">
        <div class="bg-white dark:bg-slate-900 rounded-xl shadow-2xl w-[800px] max-h-[85vh] flex flex-col border border-slate-200 dark:border-slate-700">
            
            <div class="p-4 border-b border-slate-200 dark:border-slate-800 bg-slate-50 dark:bg-slate-900 rounded-t-xl shrink-0">
                <div class="flex justify-between items-center mb-3">
                    <div>
                        <h2 class="text-sm font-bold text-slate-800 dark:text-white uppercase tracking-wide"><i class="fa-solid fa-bug text-red-500 mr-2"></i>Network Health Report</h2>
                        <p class="text-[10px] text-slate-500">Topology analysis, duplicate detection, and connectivity checks</p>
                    </div>
                    <button onclick="document.getElementById('debugModal').classList.add('hidden')" class="w-6 h-6 flex items-center justify-center rounded hover:bg-slate-200 text-slate-500 transition"><i class="fa-solid fa-times"></i></button>
                </div>

                <div class="grid grid-cols-4 gap-2">
                    <select id="filterAsset" onchange="filterDebugReport()" class="bg-white dark:bg-slate-800 border border-slate-200 dark:border-slate-700 text-slate-700 dark:text-slate-300 text-[10px] rounded px-2 py-1.5 font-bold outline-none focus:border-brand-500">
                        <option value="ALL">All Assets</option>
                        <option value="Site">Sites</option>
                        <option value="Cable">Cables</option>
                        <option value="Splice">Splice Cases</option>
                    </select>

                    <select id="filterStatus" onchange="filterDebugReport()" class="bg-white dark:bg-slate-800 border border-slate-200 dark:border-slate-700 text-slate-700 dark:text-slate-300 text-[10px] rounded px-2 py-1.5 font-bold outline-none focus:border-brand-500">
                        <option value="ALL">All Statuses</option>
                        <option value="FAILED">Failed</option>
                        <option value="WARNING">Warning</option>
                        <option value="OK">OK</option>
                    </select>

                    <select id="filterIssue" onchange="filterDebugReport()" class="bg-white dark:bg-slate-800 border border-slate-200 dark:border-slate-700 text-slate-700 dark:text-slate-300 text-[10px] rounded px-2 py-1.5 font-bold outline-none focus:border-brand-500">
                        <option value="ALL">All Issues</option>
                        <option value="Duplicate">Duplicate IDs/Names</option>
                        <option value="Topology">Topology Check</option>
                        <option value="Lead-in">Lead-in Match</option>
                    </select>

                    <input id="filterText" oninput="filterDebugReport()" type="text" placeholder="Search ID/Code..." class="bg-white dark:bg-slate-800 border border-slate-200 dark:border-slate-700 text-slate-700 dark:text-slate-300 text-[10px] rounded px-2 py-1.5 outline-none focus:border-brand-500 font-mono uppercase">
                </div>
            </div>

            <div class="flex-1 overflow-y-auto p-0 text-xs">
                <table class="w-full text-left border-collapse">
                    <thead class="bg-slate-100 dark:bg-slate-800 text-slate-500 font-bold sticky top-0 z-10 shadow-sm">
                        <tr>
                            <th class="p-2 border-b border-slate-200 dark:border-slate-700 w-24">Asset Class</th>
                            <th class="p-2 border-b border-slate-200 dark:border-slate-700">Cable/Site ID</th>
                            <th class="p-2 border-b border-slate-200 dark:border-slate-700 w-20">Status</th>
                            <th class="p-2 border-b border-slate-200 dark:border-slate-700">Issue Type</th>
                            <th class="p-2 border-b border-slate-200 dark:border-slate-700">Details</th>
                        </tr>
                    </thead>
                    <tbody id="debugReportBody" class="font-mono text-slate-700 dark:text-slate-300"></tbody>
                </table>
            </div>

            <div class="p-3 border-t border-slate-200 dark:border-slate-800 bg-slate-50 dark:bg-slate-900 rounded-b-xl flex justify-between items-center text-[10px] text-slate-500 shrink-0">
                <span id="debugStats"></span>
                <button onclick="copyDebugReport()" class="text-brand-600 font-bold hover:underline">Copy Report to Clipboard</button>
            </div>
        </div>
    </div>

    <!-- State Selection Modal -->
    <div id="stateModal" class="fixed inset-0 z-[2100] bg-slate-900/80 backdrop-blur-sm flex items-center justify-center hidden">
        <div class="bg-white dark:bg-slate-900 p-6 rounded-2xl shadow-2xl w-96 border border-slate-200 dark:border-slate-700 transform transition-all scale-100">
            <div class="text-center mb-6">
                <div class="w-12 h-12 bg-brand-50 dark:bg-brand-900/30 rounded-full flex items-center justify-center mx-auto mb-3">
                    <i class="fa-solid fa-map-location-dot text-brand-600 text-xl"></i>
                </div>
                <h2 class="text-lg font-bold text-slate-800 dark:text-white">Select Regions</h2>
                <p class="text-xs text-slate-500 mt-1">Choose the states to load data for</p>
            </div>
            
            <div class="grid grid-cols-4 gap-2 mb-6">
                <label class="group cursor-pointer relative"><input type="checkbox" class="hidden state-chk" value="NSW" checked><div class="p-2 border border-slate-200 dark:border-slate-700 rounded-lg text-center bg-slate-50 dark:bg-slate-800 hover:border-brand-300 transition-all group-has-[:checked]:bg-brand-50 group-has-[:checked]:border-brand-500 group-has-[:checked]:text-brand-700"><span class="text-xs font-bold block">NSW</span></div></label>
                <label class="group cursor-pointer relative"><input type="checkbox" class="hidden state-chk" value="VIC" checked><div class="p-2 border border-slate-200 dark:border-slate-700 rounded-lg text-center bg-slate-50 dark:bg-slate-800 hover:border-brand-300 transition-all group-has-[:checked]:bg-brand-50 group-has-[:checked]:border-brand-500 group-has-[:checked]:text-brand-700"><span class="text-xs font-bold block">VIC</span></div></label>
                <label class="group cursor-pointer relative"><input type="checkbox" class="hidden state-chk" value="QLD"><div class="p-2 border border-slate-200 dark:border-slate-700 rounded-lg text-center bg-slate-50 dark:bg-slate-800 hover:border-brand-300 transition-all group-has-[:checked]:bg-brand-50 group-has-[:checked]:border-brand-500 group-has-[:checked]:text-brand-700"><span class="text-xs font-bold block">QLD</span></div></label>
                <label class="group cursor-pointer relative"><input type="checkbox" class="hidden state-chk" value="ACT"><div class="p-2 border border-slate-200 dark:border-slate-700 rounded-lg text-center bg-slate-50 dark:bg-slate-800 hover:border-brand-300 transition-all group-has-[:checked]:bg-brand-50 group-has-[:checked]:border-brand-500 group-has-[:checked]:text-brand-700"><span class="text-xs font-bold block">ACT</span></div></label>
                <label class="group cursor-pointer relative"><input type="checkbox" class="hidden state-chk" value="SA"><div class="p-2 border border-slate-200 dark:border-slate-700 rounded-lg text-center bg-slate-50 dark:bg-slate-800 hover:border-brand-300 transition-all group-has-[:checked]:bg-brand-50 group-has-[:checked]:border-brand-500 group-has-[:checked]:text-brand-700"><span class="text-xs font-bold block">SA</span></div></label>
                <label class="group cursor-pointer relative"><input type="checkbox" class="hidden state-chk" value="WA"><div class="p-2 border border-slate-200 dark:border-slate-700 rounded-lg text-center bg-slate-50 dark:bg-slate-800 hover:border-brand-300 transition-all group-has-[:checked]:bg-brand-50 group-has-[:checked]:border-brand-500 group-has-[:checked]:text-brand-700"><span class="text-xs font-bold block">WA</span></div></label>
                <label class="group cursor-pointer relative"><input type="checkbox" class="hidden state-chk" value="TAS"><div class="p-2 border border-slate-200 dark:border-slate-700 rounded-lg text-center bg-slate-50 dark:bg-slate-800 hover:border-brand-300 transition-all group-has-[:checked]:bg-brand-50 group-has-[:checked]:border-brand-500 group-has-[:checked]:text-brand-700"><span class="text-xs font-bold block">TAS</span></div></label>
                <label class="group cursor-pointer relative"><input type="checkbox" class="hidden state-chk" value="NT"><div class="p-2 border border-slate-200 dark:border-slate-700 rounded-lg text-center bg-slate-50 dark:bg-slate-800 hover:border-brand-300 transition-all group-has-[:checked]:bg-brand-50 group-has-[:checked]:border-brand-500 group-has-[:checked]:text-brand-700"><span class="text-xs font-bold block">NT</span></div></label>
            </div>
            <button onclick="confirmStateSelection()" class="w-full bg-brand-600 hover:bg-brand-700 text-white font-bold py-3 rounded-lg text-sm shadow-lg shadow-brand-500/30 transition-all transform hover:-translate-y-0.5">Initialize Session</button>
        </div>
    </div>

    <!-- Header -->
    <header class="h-14 bg-white dark:bg-slate-900 border-b border-slate-200 dark:border-slate-800 flex items-center justify-between px-6 shrink-0 z-20 shadow-sm relative">
        <div class="flex items-center gap-3">
            <div class="bg-brand-600 p-1.5 rounded-lg shadow-lg shadow-brand-500/20">
                <i class="fa-solid fa-network-wired text-white text-sm"></i>
            </div>
            <div>
                <h1 class="font-bold text-sm tracking-tight text-slate-800 dark:text-white">FibreNet <span class="text-brand-600">Pro</span></h1>
                <div class="text-[9px] font-medium text-slate-400 uppercase tracking-widest leading-none">Developed by Jian Song</div>
            </div>
        </div>
        <div class="flex items-center gap-3">
            <input type="file" id="cableInput" accept=".json,.geojson" class="hidden" onchange="handleUpload(event, 'cable')">
            <input type="file" id="spliceInput" accept=".json,.geojson" class="hidden" onchange="handleUpload(event, 'splice')">
            <input type="file" id="siteInput" accept=".json,.geojson" class="hidden" onchange="handleUpload(event, 'site')">
            
            <div id="tour-upload" class="flex bg-slate-100 dark:bg-slate-800 p-1 rounded-lg gap-1 border border-slate-200 dark:border-slate-700">
                <label for="cableInput" class="cursor-pointer px-3 py-1.5 rounded-md text-[10px] font-bold text-slate-600 hover:bg-white hover:text-brand-600 hover:shadow-sm transition flex items-center gap-2"><i class="fa-solid fa-upload"></i> Cables</label>
                <label for="spliceInput" class="cursor-pointer px-3 py-1.5 rounded-md text-[10px] font-bold text-slate-600 hover:bg-white hover:text-purple-600 hover:shadow-sm transition flex items-center gap-2"><i class="fa-solid fa-upload"></i> Splices</label>
                <label for="siteInput" class="cursor-pointer px-3 py-1.5 rounded-md text-[10px] font-bold text-slate-600 hover:bg-white hover:text-teal-600 hover:shadow-sm transition flex items-center gap-2"><i class="fa-solid fa-upload"></i> Sites</label>
            </div>
            
            <div class="h-6 w-px bg-slate-200 dark:bg-slate-700 mx-1"></div>
            <button onclick="showDebugReport()" class="w-8 h-8 flex items-center justify-center rounded-lg hover:bg-red-50 text-slate-500 hover:text-red-600 transition" title="Connection Report"><i class="fa-solid fa-stethoscope text-xs"></i></button>
            <button id="btn-state" onclick="showStateModal()" class="w-8 h-8 flex items-center justify-center rounded-lg hover:bg-slate-100 text-slate-500 transition" title="Filter"><i class="fa-solid fa-filter text-xs"></i></button>
            <button onclick="zoomToFit()" class="w-8 h-8 flex items-center justify-center rounded-lg hover:bg-slate-100 text-slate-500 transition" title="Fit"><i class="fa-solid fa-expand text-xs"></i></button>
            <div class="h-6 w-px bg-slate-200 dark:bg-slate-700 mx-1"></div>
                <button onclick="startTour()" class="flex items-center gap-2 px-3 py-1.5 rounded-lg bg-brand-50 hover:bg-brand-100 text-brand-700 text-[10px] font-bold transition">
                    <i class="fa-regular fa-circle-question"></i> Guide
                </button>
            </div>
    </header>

    <div class="flex flex-1 overflow-hidden relative">
        <!-- Sidebar -->
        <aside id="sidebar" class="bg-slate-50 dark:bg-slate-950 border-r border-slate-200 dark:border-slate-800 flex flex-col z-10 relative w-80 shrink-0 shadow-xl">
            <div id="resizer" class="resizer-h"></div>
            
            <!-- Tabs -->
            <div class="flex border-b border-slate-200 dark:border-slate-800 bg-white dark:bg-slate-900 px-4 pt-4 shrink-0 gap-4">
                <button id="tab-browser-btn" onclick="switchTab('browser')" class="tab-btn active flex-1 pb-3 text-[11px] font-bold text-center border-b-2 border-brand-600 text-brand-700 dark:text-brand-400 transition">Asset Browser</button>
                <button id="tab-pathfinder-btn" onclick="switchTab('pathfinder')" class="tab-btn flex-1 pb-3 text-[11px] font-bold text-center border-b-2 border-transparent text-slate-500 hover:text-slate-700 transition">Pathfinder</button>
            </div>

            <!-- Tab: Browser -->
            <div id="tab-browser" class="flex-col h-full flex bg-slate-50 dark:bg-slate-950">
                <div class="p-3 border-b border-slate-200 dark:border-slate-800 shrink-0 bg-white dark:bg-slate-900">
                    <div class="float-label-group w-full">
                        <input
                            id="searchInput"
                            type="text"
                            placeholder=" "
                            style="text-transform: uppercase;"
                            oninput="renderSidebar()"
                            class="peer block w-full bg-white dark:bg-slate-900 border border-slate-300 dark:border-slate-700 
                                rounded-lg px-3.5 pb-2 pt-6 text-xs text-slate-800 dark:text-slate-200 
                                focus:ring-1 focus:ring-brand-500 focus:border-brand-500 outline-none transition"
                        >
                        <label for="searchInput" class="float-label">
                            Search by Name, ID or Site Code
                        </label>
                    </div>
                </div>
                <!-- Stats Strip -->
                <div class="grid grid-cols-4 text-[10px] text-center bg-slate-100 dark:bg-slate-900 py-3 border-b border-slate-200 dark:border-slate-800 shrink-0">
                    <div><b class="block text-sm text-slate-700 dark:text-slate-200" id="stat-cable">0</b><span class="text-slate-500">Cables</span></div>
                    <div><b class="block text-sm text-purple-600" id="stat-splice">0</b><span class="text-slate-500">Splices</span></div>
                    <div><b class="block text-sm text-teal-600" id="stat-site">0</b><span class="text-slate-500">Sites</span></div>
                    <div><b class="block text-sm text-brand-600" id="stat-km">0</b><span class="text-slate-500">Km</span></div>
                </div>
                <div id="assetList" class="flex-1 overflow-y-auto p-2 space-y-1 bg-slate-50 dark:bg-slate-950">
                    <div class="flex flex-col items-center justify-center h-48 text-slate-400 gap-2">
                        <div class="w-12 h-12 rounded-full bg-slate-100 flex items-center justify-center"><i class="fa-solid fa-layer-group text-slate-300"></i></div>
                        <span class="text-xs font-medium">No Assets Loaded</span>
                    </div>
                </div>
            </div>

            <!-- Tab: Pathfinder -->
            <div id="tab-pathfinder" class="flex flex-col h-full hidden bg-slate-50 dark:bg-slate-950">
                
                <!-- Top Section: Inputs (Resizable) -->
            <div id="pathfinderInputs" class="shrink-0 flex flex-col bg-slate-50/50 dark:bg-slate-950/50 backdrop-blur-sm relative z-10" style="height: 60%; min-height: 250px; max-height: 85%;">
                
                <div class="px-5 pt-5 pb-2 shrink-0">
                    <div class="flex items-center justify-between mb-4">
                        <h2 class="text-xs font-black uppercase tracking-widest text-slate-400">Route Configuration</h2>
                        <button type="button" onclick="resetPath()" class="text-[10px] font-bold text-slate-500 hover:text-red-500 transition flex items-center gap-1.5 bg-white dark:bg-slate-900 px-2.5 py-1.5 rounded-lg border border-slate-200 dark:border-slate-800 shadow-sm hover:shadow active:scale-95">
                            <i class="fa-solid fa-rotate-left"></i> Reset
                        </button>
                    </div>

                    <div id="tour-modes" class="grid grid-cols-3 gap-2 mb-2">
                        <button type="button" onclick="setModeUI('single')" id="seg-single" class="segment-btn active group relative flex flex-col items-center justify-center p-2 rounded-xl border border-slate-200 dark:border-slate-800 bg-white dark:bg-slate-900 hover:border-blue-300 transition-all shadow-sm">
                            <div class="w-1.5 h-1.5 rounded-full bg-slate-200 group-[.active]:bg-blue-500 mb-1.5 transition-colors"></div>
                            <span class="text-[10px] font-bold text-slate-500 group-[.active]:text-brand-600 dark:text-slate-400 dark:group-[.active]:text-white">Single</span>
                        </button>
                        
                        <button type="button" onclick="setModeUI('diverse')" id="seg-diverse" class="segment-btn group relative flex flex-col items-center justify-center p-2 rounded-xl border border-slate-200 dark:border-slate-800 bg-white dark:bg-slate-900 hover:border-emerald-300 transition-all shadow-sm">
                            <div class="w-1.5 h-1.5 rounded-full bg-slate-200 group-[.active]:bg-emerald-500 mb-1.5 transition-colors"></div>
                            <span class="text-[10px] font-bold text-slate-500 group-[.active]:text-emerald-600 dark:text-slate-400 dark:group-[.active]:text-white">Diverse</span>
                        </button>
                        
                        <button type="button" onclick="setModeUI('ring')" id="seg-ring" class="segment-btn group relative flex flex-col items-center justify-center p-2 rounded-xl border border-slate-200 dark:border-slate-800 bg-white dark:bg-slate-900 hover:border-purple-300 transition-all shadow-sm">
                            <div class="w-1.5 h-1.5 rounded-full bg-slate-200 group-[.active]:bg-purple-500 mb-1.5 transition-colors"></div>
                            <span class="text-[10px] font-bold text-slate-500 group-[.active]:text-purple-600 dark:text-slate-400 dark:group-[.active]:text-white">Ring / Multi</span>
                        </button>
                    </div>

                    <select id="modeSelect" class="hidden" onchange="handleModeChange()">
                        <option value="single">Single Fibre</option>
                        <option value="diverse">Diverse Fibres</option>
                        <option value="ring">Ring / Multi-Hop</option>
                    </select>
                </div>

                <div class="flex-1 overflow-y-auto px-5 pb-2 custom-scrollbar relative z-0">
                    
                    <div class="journey-line-container relative mb-5 pt-1">
                        <div class="journey-line"></div>
                        <div id="pathInputs" class="relative z-10 space-y-3"></div>
                    </div>

                    <div class="space-y-3 pb-4">
                        
                        <details id="tour-avoid" class="group bg-white dark:bg-slate-900 rounded-xl border border-slate-200 dark:border-slate-800 shadow-sm overflow-hidden">
                            <summary class="flex items-center justify-between p-3 cursor-pointer bg-slate-50/50 dark:bg-slate-800/50 hover:bg-slate-50 transition select-none outline-none">
                                <div class="flex items-center gap-2">
                                    <div class="w-6 h-6 rounded-md bg-red-50 dark:bg-red-900/30 flex items-center justify-center text-red-500">
                                        <i class="fa-solid fa-ban text-[10px]"></i>
                                    </div>
                                    <span class="text-[11px] font-bold text-slate-700 dark:text-slate-200">Specific Cable/Splice Avoidance</span>
                                </div>
                                <div id="constraintSelector" class="flex gap-1" onclick="event.preventDefault(); event.stopPropagation();"></div> 
                                <i class="fa-solid fa-chevron-down text-slate-300 text-[10px] group-open:rotate-180 transition-transform"></i>
                            </summary>
                            
                            <div class="p-3 border-t border-slate-100 dark:border-slate-800 bg-white dark:bg-slate-900">
                                <div id="constraintsUI" class="space-y-3"></div>
                            </div>
                        </details>

                        <details id="tour-sim" class="group bg-white dark:bg-slate-900 rounded-xl border border-slate-200 dark:border-slate-800 shadow-sm overflow-hidden">
                            <summary class="flex items-center justify-between p-3 cursor-pointer bg-slate-50/50 dark:bg-slate-800/50 hover:bg-slate-50 transition select-none outline-none">
                                <div class="flex items-center gap-2">
                                    <div class="w-6 h-6 rounded-md bg-emerald-50 dark:bg-emerald-900/30 flex items-center justify-center text-emerald-500">
                                        <i class="fa-solid fa-route text-[10px]"></i>
                                    </div>
                                    <span class="text-[11px] font-bold text-slate-700 dark:text-slate-200">
                                        Path Similarity %
                                    </span>
                                </div>
                                <span id="pathSimilarityLabel" class="text-[10px] text-slate-400 mr-2">
                                    75% max overlap
                                </span>
                                <i class="fa-solid fa-chevron-down text-slate-300 text-[10px] group-open:rotate-180 transition-transform"></i>
                            </summary>

                            <div class="p-3 border-t border-slate-100 dark:border-slate-800 bg-white dark:bg-slate-900 space-y-2">
                                <p class="text-[10px] text-slate-500 leading-snug">
                                    Find paths that are more similar or more unique
                                </p>
                                <div class="flex items-center gap-3">
                                    <span class="text-[10px] text-slate-400 w-12">Unique</span>
                                    <input id="pathSimilaritySlider"
                                        type="range"
                                        min="40" max="95" step="5" value="75"
                                        class="flex-1 accent-brand-600 cursor-pointer"
                                        oninput="updateSimilarityLabel(this.value)">
                                    <span class="text-[10px] text-slate-400 w-16 text-right">Similar</span>
                                </div>
                                <p class="text-[10px] text-slate-400 italic">
                                    <i class="fa-solid fa-circle-info text-brand-500"></i> Lower % = forces unique paths.<br>
                                    Higher % = allows similar variations.
                                </p>
                            </div>
                        </details>

                        <details id="tour-prefs" class="group bg-white dark:bg-slate-900 rounded-xl border border-slate-200 dark:border-slate-800 shadow-sm overflow-hidden">
                            <summary class="flex items-center justify-between p-3 cursor-pointer bg-slate-50/50 dark:bg-slate-800/50 hover:bg-slate-50 transition select-none outline-none">
                                <div class="flex items-center gap-2">
                                    <div class="w-6 h-6 rounded-md bg-brand-50 dark:bg-brand-900/30 flex items-center justify-center text-brand-600">
                                        <i class="fa-solid fa-sliders text-[10px]"></i>
                                    </div>
                                    <span class="text-[11px] font-bold text-slate-700 dark:text-slate-200">Preferences</span>
                                </div>
                                <i class="fa-solid fa-chevron-down text-slate-300 text-[10px] group-open:rotate-180 transition-transform"></i>
                            </summary>
                            
                            <div class="p-3 border-t border-slate-100 dark:border-slate-800">
                                <div class="flex justify-between items-center mb-2">
                                    <span class="text-[9px] font-bold text-slate-400 uppercase">Avoid Features</span>
                                    <label class="text-[9px] font-bold text-brand-600 cursor-pointer hover:underline flex items-center gap-1">
                                        <input type="checkbox" onchange="toggleAllPriorities(this)" class="accent-brand-600 w-3 h-3"> All
                                    </label>
                                </div>
                                
                                <div id="divConstraintsCard" class="hidden w-full mb-3 bg-blue-50/50 dark:bg-blue-900/10 p-2 rounded-lg border border-blue-100 dark:border-blue-800">
                                    <div id="diversityList" class="space-y-1"></div>
                                </div>

                                <div id="priorityList" class="space-y-1 mb-4"></div>

                                <div class="bg-slate-50 dark:bg-slate-800 rounded-lg p-2 border border-slate-100 dark:border-slate-700">
                                    <label class="text-[9px] font-bold text-slate-500 uppercase block mb-1">Max Distance (km)</label>
                                    <div class="float-label-group w-full">
                                        <input
                                            id="maxDist"
                                            type="number"
                                            placeholder=" "
                                            class="peer block w-full bg-white dark:bg-slate-900 border border-slate-300 dark:border-slate-700 
                                                rounded-lg px-3.5 pb-2 pt-6 text-xs text-slate-800 dark:text-slate-200
                                                focus:ring-1 focus:ring-brand-500 focus:border-brand-500 outline-none transition"
                                        >
                                        <label for="maxDist" class="float-label">Max Distance (km)</label>
                                    </div>
                                </div>
                            </div>
                        </details>
                    </div>
                </div>

                <div class="p-4 m-4 relative flex flex-col items-center justify-center transform transition-all animate-fade-in">
                    <button type="button" id="btn-calculate" onclick="findPath()" class="
                        w-full 
                        py-3 px-6 
                        rounded-xl 
                        font-bold 
                        text-sm
                        transition-bg-pos 
                        duration-500 
                        ease-in-out 
                        btn-shine-pathfinder 
                        shadow-2xl shadow-brand-500/50 
                        transform hover:scale-[1.01] active:scale-[0.99]
                        focus:outline-none focus:ring-4 focus:ring-brand-500/50
                    ">
                        <i class="fa-solid fa-bolt mr-2"></i> Calculate Optimal Route
                    </button>
                </div>
            </div>
                <!-- Vertical Resizer -->
                <div id="vResizer" class="resizer-v" title="Drag to resize"></div>

                <!-- Bottom Section: Results -->
                <div id="resultsArea" class="hidden flex-1 flex flex-col min-h-0 bg-white dark:bg-slate-900 shadow-[0_-4px_6px_-1px_rgba(0,0,0,0.05)]">
                     <div class="px-3 py-2 bg-slate-50 dark:bg-slate-800 text-[10px] font-bold text-slate-500 uppercase border-b border-slate-200 dark:border-slate-700 flex justify-between shrink-0">
                         <span id="resultsTitle" class="text-brand-700">Route Details</span>
                         <span id="resultsCount"></span>
                     </div>
                     <div id="pathResultsList" class="flex-1 overflow-y-auto p-0 space-y-0 min-h-0 pb-16"></div>
                </div>
            </div>
        </aside>

        <main id="map-container">
            <div id="map"></div>
            
            <!-- Updated Floating Options UI -->
            <div id="solutionSelector" class="absolute top-20 right-6 z-[400] hidden flex-col w-72 bg-white/95 dark:bg-slate-900/95 backdrop-blur-md rounded-2xl shadow-2xl border border-slate-200 dark:border-slate-700 overflow-hidden transform transition-all animate-fade-in origin-top-right">
                <div onclick="toggleRoutesPanel()" class="cursor-pointer p-3 border-b border-slate-200 dark:border-slate-800 bg-slate-50/80 dark:bg-slate-900 flex justify-between items-center shrink-0 hover:bg-slate-100 dark:hover:bg-slate-800 transition-colors select-none">
                        <div class="flex items-center gap-2">
                        <i id="routesToggleIcon" class="fa-solid fa-chevron-down text-slate-400 text-xs transition-transform duration-300"></i>
                        <div class="flex items-center gap-2">
                            <i class="fa-solid fa-list-check text-brand-600"></i>
                            <span class="text-xs font-bold uppercase tracking-wider text-slate-700 dark:text-slate-300">Found Routes</span>
                        </div>
                        </div>
                        <span class="bg-brand-100 text-brand-700 dark:bg-brand-900 dark:text-brand-300 px-2 py-0.5 rounded-full text-[10px] font-bold" id="solutionCount">0</span>
                </div>
                
                <div id="routesContentWrapper" class="transition-all duration-300 ease-in-out max-h-[60vh] opacity-100 overflow-hidden">
                    <div class="flex flex-col p-3 gap-2 overflow-y-auto max-h-[60vh] custom-scrollbar" id="solutionBtns"></div>
                </div>
            </div>
            
            <div
                id="pathSelectorBtns"
                class="absolute top-4 right-6 z-[410] hidden bg-white/95 dark:bg-slate-900/95 backdrop-blur-md rounded-2xl shadow-2xl border border-slate-200 dark:border-slate-700 px-3 py-2 flex gap-2 items-center">
            </div>

            <div id="pathSummaryCard" class="absolute bottom-8 left-1/2 -translate-x-1/2 z-[400] hidden bg-white/95 dark:bg-slate-900/95 backdrop-blur py-2 px-5 rounded-full shadow-2xl border border-slate-200 dark:border-slate-700 flex gap-5 items-center transform transition-all hover:-translate-y-1">
                <div class="flex items-center gap-3">
                    <div class="w-8 h-8 rounded-full bg-brand-100 dark:bg-brand-900 flex items-center justify-center text-brand-600 dark:text-brand-400"><i class="fa-solid fa-flag-checkered text-sm"></i></div>
                    <div>
                        <div class="text-[9px] font-bold text-slate-400 uppercase tracking-wider">Total Distance</div>
                        <div class="text-base font-bold text-slate-800 dark:text-white leading-none"><span id="summaryDistance">0</span> <span class="text-[10px] text-slate-500 font-normal">km</span></div>
                    </div>
                </div>
                <div class="h-8 w-px bg-slate-200 dark:bg-slate-700"></div>
                <button onclick="exportPathCSV()" class="bg-slate-100 hover:bg-slate-200 text-slate-600 rounded-full px-3 py-1.5 text-[10px] font-bold flex items-center gap-2 transition"><i class="fa-solid fa-download"></i> CSV Report</button>
            </div>
        </main>
    </div>

    <div id="tour-tooltip" class="hidden fixed z-[10000] w-72 bg-white dark:bg-slate-900 rounded-xl shadow-2xl border border-slate-200 dark:border-slate-700 p-4 opacity-0 transform translate-y-4">
        <div class="flex items-center justify-between mb-2">
            <span class="bg-brand-100 dark:bg-brand-900 text-brand-700 dark:text-brand-300 text-[10px] font-bold px-2 py-0.5 rounded-full uppercase tracking-wide">Guide</span>
            <button onclick="endTour()" class="text-slate-400 hover:text-slate-600"><i class="fa-solid fa-times"></i></button>
        </div>
        <h4 id="tour-title" class="font-bold text-slate-800 dark:text-white text-sm mb-1">Title</h4>
        <p id="tour-desc" class="text-slate-500 dark:text-slate-400 text-xs leading-relaxed mb-4">Description.</p>
        <div class="flex justify-between items-center border-t border-slate-100 dark:border-slate-800 pt-3">
            <span id="tour-progress" class="text-[10px] text-slate-400 font-bold font-mono">1/9</span>
            <div class="flex gap-2">
                <button onclick="endTour()" class="text-[10px] text-slate-500 font-bold hover:text-slate-800 dark:hover:text-white transition mr-2">Skip</button>
                <button onclick="prevStep()" class="text-[10px] bg-slate-100 hover:bg-slate-200 text-slate-600 px-3 py-1.5 rounded-lg font-bold transition">
                    <i class="fa-solid fa-chevron-left mr-1"></i> Prev
                </button>
                <button onclick="nextStep()" class="text-[10px] bg-brand-600 hover:bg-brand-700 text-white px-3 py-1.5 rounded-lg font-bold shadow-sm transition">
                    Next <i class="fa-solid fa-chevron-right ml-1"></i>
                </button>
            </div>
        </div>
    </div>

    <script>
        // --- DEFAULTS & CONFIG ---
        const DEFAULT_PRIORITIES = [
            { id: 'rs-no', label: 'RS-NO', type: 'node', code: 'RS-NO' },
            { id: 'rs-be', label: 'RS-BE', type: 'node', code: 'RS-BE' },
            { id: 'avoidCiti', label: 'Citipower Pit', type: 'node', key: 'citi' },
            { id: 'avoidIOF', label: 'IOF Cable', type: 'edge', key: 'iof' },
            { id: 'rs-nh', label: 'RS-NH', type: 'node', code: 'RS-NH' },
            { id: 'rs-oi', label: 'RS-OI', type: 'node', code: 'RS-OI' },
            { id: 'avoidNew', label: 'New Cable', type: 'edge', key: 'new' },
            { id: 'rs-ra', label: 'RS-RA', type: 'node', code: 'RS-RA' },
            { id: 'rs-cc', label: 'RS-CC', type: 'node', code: 'RS-CC' },
            { id: 'avoidAerial', label: 'Aerial Cable', type: 'edge', key: 'aerial' },
            { id: 'rs-rb', label: 'RS-RB', type: 'node', code: 'RS-RB' }
        ];

        const DEFAULT_DIVERSITY = [
            { id: 'noOverlap', label: 'No Folded Fibres', checked: true },
            { id: 'noCommonNodes', label: 'No Common Splices (Cross-Over)', checked: true },
            { id: 'distinctLead', label: 'Dual Lead-ins', checked: true }
        ];

        // --- GLOBALS ---
        let map, tileLayer, cableLayer, spliceLayer, siteLayer, pathLayer, endpointLayer;
        let allCables=[], allSplices=[], allSites=[];
        let spliceLookup={}, nameToIdMap={}, cableLookup={}, cableSegmentsByName={}, cableSegmentsById={};
        let layerLookup = {}; 
        let networkGraph=null, ufParent={};
        let siteConnectivity = {}; 
        let debugReport = [];
        
        let solutionSets = []; 
        let currentSolutionIndex = 0;
        let foundPaths = []; 
        let currentPathIndex = 0; 

        // NEW: hover preview flags
        let previewMode = false;           // true when we're showing a hover preview
        let highlightAllOnHover = false;   // when true, all paths in the solution are drawn as active

                
        let constraintState = {}; 
        let currentScopeId = '0';

        const stateBounds = { "NSW":[140.9,-37.6,153.7,-28.1], "VIC":[140.9,-39.2,150.1,-33.9], "QLD":[137.9,-29.2,153.6,-10.0], "ACT":[148.7,-35.9,149.4,-35.1], "SA":[129.0,-38.1,141.0,-25.9], "WA":[112.9,-35.2,129.0,-13.7], "TAS":[143.8,-43.7,148.5,-39.5], "NT":[129.0,-26.0,138.0,-10.9] };
        let selectedStates = new Set(['NSW','VIC','QLD']);
        const rawData = { cable:[], splice:[], site:[] };
        let searchTimeout;

        // --- UTILS ---

        function checkDuplicates() {
            // Helper to check duplicates in a specific list
            const scan = (list, typeLabel) => {
                const idMap = new Map();
                const nameMap = new Map();

                // 1. Count occurrences
                list.forEach(f => {
                    const p = f.properties;
                    const id = p.ID ? String(p.ID).trim().toUpperCase() : null;
                    const name = p.NAME ? String(p.NAME).trim().toUpperCase() : (p.SITE_CODE ? String(p.SITE_CODE).trim().toUpperCase() : null);

                    if (id) {
                        if (!idMap.has(id)) idMap.set(id, []);
                        idMap.get(id).push(p);
                    }
                    if (name) {
                        if (!nameMap.has(name)) nameMap.set(name, []);
                        nameMap.get(name).push(p);
                    }
                });

                // 2. Report Duplicates
                idMap.forEach((items, id) => {
                    if (items.length > 1) {
                        let isIssue = true;
                        let detailMsg = `ID found ${items.length} times`;

                        // [UPDATED] Special Logic for Cables
                        // Only flag as duplicate if they have DIFFERENT connectivity (LINK1/LINK2)
                        // This ignores cables that are just split into multiple segments (MultiLineString)
                        if(typeLabel === 'Cable') {
                             const uniqueLinks = new Set(items.map(i => {
                                 const l1 = i.LINK1 || 'NULL';
                                 const l2 = i.LINK2 || 'NULL';
                                 // Sort links so A->B and B->A are treated as same connection
                                 return [l1, l2].sort().join('<->');
                             }));
                             
                             if(uniqueLinks.size === 1) isIssue = false; 
                             else detailMsg = `ID shared by cables with ${uniqueLinks.size} different endpoint pairs`;
                        }

                        if (isIssue) {
                            debugReport.push({
                                code: id,
                                assetType: typeLabel,
                                result: 'WARNING',
                                type: 'Duplicate ID',
                                details: detailMsg
                            });
                        }
                    }
                });

                nameMap.forEach((items, name) => {
                    if (items.length > 1) {
                        let isIssue = true;
                        let detailMsg = `Name/Code found ${items.length} times`;

                        // [UPDATED] Special Logic for Cables
                        // Treat cables with same Name but different LINK1 and LINK2 as duplicates
                        if(typeLabel === 'Cable') {
                             const uniqueLinks = new Set(items.map(i => {
                                 const l1 = i.LINK1 || 'NULL';
                                 const l2 = i.LINK2 || 'NULL';
                                 return [l1, l2].sort().join('<->');
                             }));
                             
                             if(uniqueLinks.size === 1) isIssue = false; 
                             else detailMsg = `Name shared by cables with ${uniqueLinks.size} different endpoint pairs`;
                        }

                        if (isIssue) {
                            debugReport.push({
                                code: name,
                                assetType: typeLabel,
                                result: 'WARNING',
                                type: 'Duplicate Name',
                                details: detailMsg
                            });
                        }
                    }
                });
            };

            scan(allSites, 'Site');
            scan(allCables, 'Cable');
            scan(allSplices, 'Splice');
        }
        // --- [NEW] Progress UI Helper ---
        function updateSearchProgress(percent, message) {
            const bar = document.getElementById('progressBar');
            const container = document.getElementById('progressContainer');
            const sub = document.getElementById('loadingSubtitle');
            const title = document.getElementById('loadingTitle');

            if(container) container.classList.remove('hidden');
            if(title) title.innerText = "Analyzing Network...";
            
            // Smoothly animate the bar width
            if(bar) bar.style.width = Math.min(100, Math.max(0, percent)) + '%';
            
            // Update the text status
            if(sub) sub.innerHTML = `<i class="fa-solid fa-circle-notch fa-spin mr-2"></i> ${message}`;
        }

        function addLegend() {
            if(!map) return;
            const div = L.DomUtil.create('div', 'legend bg-white/95 dark:bg-slate-900/95 p-3 rounded-lg shadow-xl text-[10px] border border-slate-200 dark:border-slate-800 backdrop-blur');
            div.innerHTML = `<b class="block mb-2 text-slate-500 uppercase tracking-widest font-bold text-[9px]">Map Legend</b>
            <div class="grid grid-cols-2 gap-x-4 gap-y-2">
                <div class="flex items-center gap-2"><span class="bg-teal-500 w-2 h-2 rounded-full ring-1 ring-teal-200"></span> Site</div>
                <div class="flex items-center gap-2"><span class="bg-purple-600 w-2 h-2 rounded-full ring-1 ring-purple-200"></span> Splice Case</div>
                <div class="flex items-center gap-2"><span class="bg-brand-600 w-3 h-1 rounded"></span> Existing Cable</div>
                <div class="flex items-center gap-2"><span class="bg-emerald-500 w-3 h-1 rounded"></span> New Cable</div>
            </div>`;
            L.DomUtil.get(map.getContainer()).appendChild(div);
            div.style.position = 'absolute'; div.style.bottom = '20px'; div.style.right = '50px'; div.style.zIndex = 400;
        }
        function zoomToFit() {
            if(!map) return;
            const b = L.latLngBounds([]);
            if(cableLayer && cableLayer.getBounds().isValid()) b.extend(cableLayer.getBounds());
            if(spliceLayer && spliceLayer.getBounds().isValid()) b.extend(spliceLayer.getBounds());
            if(b.isValid()) map.fitBounds(b, {padding:[50,50]});
        }
        function updateMarkerSizes() {
            if(!map) return;
            const z = map.getZoom();
            const r = z>16?6 : z>14?4 : z>12?2 : 0.5;
            if(spliceLayer) spliceLayer.eachLayer(l => l.setRadius(r));
            if(siteLayer) siteLayer.eachLayer(l => l.setRadius(r+2));
        }

        // --- INIT ---
        window.onload = function() { 
            handleModeChange();
            renderPriorityList(); 
            renderDiversityList();
            initResizers();
            // Open modal and sync checkboxes with current selectedStates
            showStateModal();
        };

        
        // [INSERT NEW FUNCTION]
        function updateSimilarityLabel(val) {
            const label = document.getElementById('pathSimilarityLabel');
            if(label) {
                let text = 'Allow similar';
                if(val < 60) text = 'Force unique';
                else if(val < 85) text = 'Balanced';
                
                label.innerText = `${val}% max overlap Â· ${text}`;
            }
        }

        function initResizers() {
            const rzH = document.getElementById('resizer'); const sb = document.getElementById('sidebar'); let isResizingH = false;
            rzH.addEventListener('mousedown', (e) => { isResizingH = true; rzH.classList.add('active'); document.body.style.cursor = 'col-resize'; e.preventDefault(); });
            document.addEventListener('mousemove', (e) => { if(isResizingH) { sb.style.width = Math.max(280, Math.min(e.clientX, 600)) + 'px'; } });
            
            const rzV = document.getElementById('vResizer'); const topPanel = document.getElementById('pathfinderInputs'); let isResizingV = false;
            rzV.addEventListener('mousedown', (e) => { isResizingV = true; rzV.classList.add('active'); document.body.style.cursor = 'row-resize'; e.preventDefault(); });
            document.addEventListener('mousemove', (e) => { if(isResizingV) { const sbRect = sb.getBoundingClientRect(); const h = e.clientY - sbRect.top - 45; topPanel.style.height = Math.max(200, Math.min(h, sbRect.height - 100)) + 'px'; topPanel.style.maxHeight = 'none'; } });

            document.addEventListener('mouseup', () => { isResizingH = false; isResizingV = false; rzH.classList.remove('active'); rzV.classList.remove('active'); document.body.style.cursor = ''; if(map) map.invalidateSize(); });
        }

        function showStateModal() { 
            const modal = document.getElementById('stateModal');
            
            // Sync checkboxes with current selectedStates
            document.querySelectorAll('.state-chk').forEach(cb => {
                cb.checked = selectedStates.has(cb.value);
            });

            modal.classList.remove('hidden');
        }

        function confirmStateSelection() {
            // Snapshot current selection
            const prevStates = new Set(selectedStates);
            
            // Build new selection from checkboxes
            const newStates = new Set();
            document.querySelectorAll('.state-chk:checked').forEach(cb => newStates.add(cb.value));

            // Detect if anything actually changed
            let changed = false;
            if (prevStates.size !== newStates.size) {
                changed = true;
            } else {
                for (let s of newStates) {
                    if (!prevStates.has(s)) {
                        changed = true;
                        break;
                    }
                }
            }

            // Update the global selectedStates Set in-place
            selectedStates.clear();
            newStates.forEach(s => selectedStates.add(s));

            // Close modal
            document.getElementById('stateModal').classList.add('hidden');

            // Always ensure map is initialised, but only reprocess if selection changed
            setTimeout(() => { 
                if (!map) initMap();
                if (changed && rawData.cable.length > 0) {
                    reprocessAll();
                }
            }, 50);
        }


        function initMap() {
            if(map) return;
            map = L.map('map', { preferCanvas:true, zoomControl:false }).setView([-25, 134], 4);
            L.control.zoom({position:'bottomright'}).addTo(map);
            tileLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {attribution:'&copy; CARTO'}).addTo(map);
            setTimeout(() => { map.invalidateSize(); }, 200);
            cableLayer = L.geoJSON(null, { style: getCableStyle, onEachFeature: onEachCable, smoothFactor:1.5, interactive: true }).addTo(map);
            spliceLayer = L.geoJSON(null, { pointToLayer: createSpliceMarker, onEachFeature: onEachSplice, interactive: true }).addTo(map);
            siteLayer = L.geoJSON(null, { pointToLayer: createSiteMarker, onEachFeature: onEachSite, interactive: true }).addTo(map);
            pathLayer = L.geoJSON(null, { style: getPathStyle, onEachFeature: onEachPathSegment, interactive: true }).addTo(map);
            endpointLayer = L.layerGroup().addTo(map); 
            map.on('zoomend', updateMarkerSizes);
            map.on('click', handleMapClick);
            addLegend();
        }

        function handleMapClick(e) {
            const clickPoint = map.latLngToContainerPoint(e.latlng);
            const hits = [];

            [allSites, allSplices].forEach((list, i) => {
                list.forEach(f => {
                    const latLng = L.latLng(f.geometry.coordinates[1], f.geometry.coordinates[0]);
                    const point = map.latLngToContainerPoint(latLng);
                    if(clickPoint.distanceTo(point) <= 12) hits.push({ type: i===0?'Site':'Splice', p: f.properties, latlng: f.geometry.coordinates });
                });
            });

            allCables.forEach(f => {
                const coords = f.geometry.coordinates; 
                if(!coords || coords.length < 2) return;
                for(let i=0; i<coords.length-1; i++) {
                    const p1 = map.latLngToContainerPoint([coords[i][1], coords[i][0]]);
                    const p2 = map.latLngToContainerPoint([coords[i+1][1], coords[i+1][0]]);
                    if(distToSegment(clickPoint, p1, p2) <= 12) {
                        hits.push({ type: 'Cable', p: f.properties });
                        break; 
                    }
                }
            });

            if(hits.length > 0) {
                if(hits.length === 1) {
                    const f = hits[0];
                    let content = renderPopupCard(f);
                    L.popup().setLatLng(e.latlng).setContent(content).openOn(map);
                } else {
                    let content = `<div class="bg-slate-50 border-b border-slate-200 p-3 font-bold text-xs text-slate-700 uppercase tracking-wide flex justify-between"><span>Assets Found</span><span class="bg-slate-200 text-slate-600 px-1.5 rounded text-[10px]">${hits.length}</span></div><div class="max-h-64 overflow-y-auto">`;
                    hits.forEach(f => { content += renderCompactListItem(f); });
                    content += `</div>`;
                    L.popup().setLatLng(e.latlng).setContent(content).openOn(map);
                }
            }
        }
        
        function renderPopupCard(f) {
            const p = f.p; const type = f.type;
            const title = p.NAME || p.SITE_CODE || 'Unknown Asset';
            const sub = type === 'Site' ? p.CONSTRUCTION_STATUS : (type === 'Cable' ? p.CABLE_STATUS : p.ADDRESS || 'No Address');
            const id = p.ID;
            
            let iconClass = 'fa-circle-question'; let badgeClass = 'bg-slate-100 text-slate-600';
            if(type==='Site') { iconClass='fa-tower-cell'; badgeClass='bg-teal-50 text-teal-700'; }
            if(type==='Splice') { iconClass='fa-circle-dot'; badgeClass='bg-purple-50 text-purple-700'; }
            if(type==='Cable') { iconClass='fa-bolt'; badgeClass='bg-brand-50 text-brand-700'; }

            let metaHtml = '';
            if(type === 'Cable') {
                metaHtml = `<div class="grid grid-cols-2 gap-2 text-[10px] mt-3 bg-slate-50 p-2 rounded border border-slate-100"><div><span class="text-slate-400 block">Fibres</span><span class="font-mono font-bold text-slate-700">${p.FIBRES||'-'}</span></div><div><span class="text-slate-400 block">Length</span><span class="font-mono font-bold text-slate-700">${p.SPAN_LENGTH}m</span></div><div><span class="text-slate-400 block">Type</span><span class="font-mono font-bold text-slate-700">${p.CONSTRUCT_TYPE||'-'}</span></div><div><span class="text-slate-400 block">IOF</span><span class="font-mono font-bold text-slate-700">${p.IOF||'N'}</span></div></div>`;
            } else if (type === 'Site' && p.LINKED_IDS) {
                const ids = p.LINKED_IDS.join(', ');
                metaHtml = `<div class="mt-3 bg-slate-50 p-2 rounded border border-slate-100 text-[10px]"><span class="text-slate-400 block">Linked Node IDs (${p.LINKED_IDS.length})</span><span class="font-mono font-bold text-slate-700 select-all break-words">${ids}</span></div>`;
            } else {
                metaHtml = `<div class="mt-3 bg-slate-50 p-2 rounded border border-slate-100 text-[10px]"><span class="text-slate-400 block">System ID</span><span class="font-mono font-bold text-slate-700 select-all">${id}</span></div>`;
            }

            const mode = document.getElementById('modeSelect').value;
            let actionsHtml = '';
            const clickId = type === 'Site' && p.SITE_CODE ? p.SITE_CODE : id;
            
            if(type !== 'Cable') {
                if(mode === 'ring') {
                    const stops = document.querySelectorAll('.ring-stop');
                    let btns = '';
                    stops.forEach((inp, idx) => {
                        const char = String.fromCharCode(65 + idx);
                        btns += `<button onclick="setVal('stop${idx}','${clickId}')" class="flex items-center justify-center gap-1.5 py-1.5 rounded bg-brand-50 hover:bg-brand-100 text-brand-700 text-[10px] font-bold transition w-full mb-1">Set Hop ${char}</button>`;
                    });
                    actionsHtml = `<div class="mt-3 pt-3 border-t border-slate-100 grid grid-cols-2 gap-1">${btns}</div>`;
                } else {
                    actionsHtml = `<div class="grid grid-cols-2 gap-2 mt-3 pt-3 border-t border-slate-100"><button onclick="setVal('pathStart','${clickId}')" class="flex items-center justify-center gap-1.5 py-1.5 rounded bg-emerald-50 hover:bg-emerald-100 text-emerald-700 text-[10px] font-bold transition"><i class="fa-solid fa-play"></i> Set Start</button><button onclick="setVal('pathEnd','${clickId}')" class="flex items-center justify-center gap-1.5 py-1.5 rounded bg-red-50 hover:bg-red-100 text-red-700 text-[10px] font-bold transition"><i class="fa-solid fa-flag-checkered"></i> Set End</button></div>`;
                }
            }

            return `<div class="font-sans p-4 min-w-[240px]"><div class="flex items-start gap-3"><div class="w-8 h-8 rounded-lg ${badgeClass} flex items-center justify-center shrink-0"><i class="fa-solid ${iconClass}"></i></div><div class="min-w-0 flex-1"><div class="font-bold text-sm text-slate-800 leading-tight truncate" title="${title}">${title}</div><div class="text-[10px] font-medium text-slate-500 uppercase tracking-wide mt-0.5">${type} â€¢ ${sub}</div></div></div>${metaHtml}${actionsHtml}</div>`;
        }
        
        function renderCompactListItem(f) {
            const p = f.p; const type = f.type;
            const title = p.NAME || p.SITE_CODE || p.ID;
            let icon = 'fa-circle-question'; let color = 'text-slate-400';
            if(type==='Site') { icon='fa-tower-cell'; color='text-teal-600'; }
            else if(type==='Splice') { icon='fa-circle-dot'; color='text-purple-600'; }
            else { icon='fa-bolt'; color='text-brand-600'; }
            const clickId = type === 'Site' ? p.SITE_CODE : p.ID;
            return `<div class="p-3 border-b border-slate-100 last:border-0 hover:bg-slate-50 cursor-pointer flex items-center gap-3 transition group" onclick="openSpecificPopup('${clickId}', '${type}')"><i class="fa-solid ${icon} ${color} w-4 text-center group-hover:scale-110 transition-transform"></i><div class="min-w-0 flex-1"><div class="font-bold text-[11px] text-slate-700 truncate">${title}</div><div class="text-[9px] text-slate-400 font-mono truncate">${p.ID}</div></div><i class="fa-solid fa-chevron-right text-[10px] text-slate-300"></i></div>`;
        }

        function distToSegment(p, v, w) {
            const l2 = dist2(v, w);
            if (l2 === 0) return Math.sqrt(dist2(p, v));
            let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
            t = Math.max(0, Math.min(1, t));
            return Math.sqrt(dist2(p, { x: v.x + t * (w.x - v.x), y: v.y + t * (w.y - v.y) }));
        }
        function dist2(v, w) { return (v.x - w.x)**2 + (v.y - w.y)**2; }

        // --- [INSERT NEW FUNCTION] Geometry Helper ---
        function getIntersectionPoint(s1, s2) {
            const x1 = s1.x1, y1 = s1.y1, x2 = s1.x2, y2 = s1.y2;
            const x3 = s2.x1, y3 = s2.y1, x4 = s2.x2, y4 = s2.y2;
            
            const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
            if (denom === 0) return null; // Parallel

            const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
            const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;

            if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {
                return { x: x1 + ua * (x2 - x1), y: y1 + ua * (y2 - y1) };
            }
            return null;
        }

        window.openSpecificPopup = function(id, type) {
            let f = null;
            if (type === 'Cable') f = cableLookup[id];
            else if (type === 'Splice') f = spliceLookup[id];
            else if (type === 'Site') { f = allSites.find(s => s.properties.SITE_CODE === id); }
            if(!f) return;
            const content = renderPopupCard({type:type, p:f.properties});
            let latlng;
            if(type==='Cable') latlng = map.getCenter(); 
            else latlng = [f.geometry.coordinates[1], f.geometry.coordinates[0]];
            L.popup().setLatLng(latlng).setContent(content).openOn(map);
        };

        // --- FILE HANDLING ---
        function handleUpload(e, type) {
            const file = e.target.files[0];
            if(!file) return;
            const reader = new FileReader();
            reader.onload = (ev) => {
                try {
                    const json = JSON.parse(ev.target.result);
                    rawData[type] = json.features || (json.type==='Feature'?[json]:[]);
                    reprocessAll();
                } catch(err) { alert("Invalid GeoJSON"); }
            };
            reader.readAsText(file);
        }

        function reprocessAll() {
            const overlay = document.getElementById('loadingOverlay');
            const title = document.getElementById('loadingTitle');
            const subtitle = document.getElementById('loadingSubtitle');
            const progressContainer = document.getElementById('progressContainer');

            if (overlay && title && subtitle && progressContainer) {
                title.innerText = 'Loading network data...';
                subtitle.innerText = 'Indexing cables, splices and sites.';
                progressContainer.classList.add('hidden');
                overlay.classList.remove('hidden');
            }
            document.getElementById('loadingOverlay').classList.remove('hidden');
            setTimeout(() => {
                if(cableLayer) cableLayer.clearLayers(); if(spliceLayer) spliceLayer.clearLayers(); if(siteLayer) siteLayer.clearLayers();
                allCables=[]; allSplices=[]; allSites=[]; 
                spliceLookup={}; nameToIdMap={}; cableLookup={}; cableSegmentsByName={}; cableSegmentsById={}; 
                networkGraph=null; layerLookup = {}; siteConnectivity = {}; 
                
                // Reset Report
                debugReport = [];

                allSplices = filterByState(rawData.splice, false);
                if(spliceLayer) spliceLayer.addData({type:"FeatureCollection", features:allSplices});
                indexNodes(allSplices);

                allCables = filterByState(rawData.cable, true);
                if(cableLayer) cableLayer.addData({type:"FeatureCollection", features:allCables});
                allCables.forEach(f => {
                    const p = f.properties;
                    if(p.ID) { cableLookup[p.ID]=f; if(!cableSegmentsById[p.ID]) cableSegmentsById[p.ID]=[]; cableSegmentsById[p.ID].push(f); }
                    if(p.NAME) { if(!cableSegmentsByName[p.NAME]) cableSegmentsByName[p.NAME]=[]; cableSegmentsByName[p.NAME].push(f); }
                });
                
                deriveSiteConnectivity(allCables);
                const sites = filterByState(rawData.site, false);
                if(allCables.length > 0) {
                    allSites = mapSitesToConnectivity(sites);
                    if(siteLayer) siteLayer.addData({type:"FeatureCollection", features:allSites});
                    indexNodes(allSites);
                }

                // --- NEW: RUN DUPLICATE CHECKS ---
                checkDuplicates();

                updateStats(); renderSidebar();
                if(allCables.length > 0) { buildGraph(); zoomToFit(); }
                document.getElementById('loadingOverlay').classList.add('hidden');
            }, 100);
        }

        function filterByState(list, isLine) {
            if(!list) return [];
            return list.filter(f => {
                if(!f.geometry?.coordinates) return false;
                let lat, lng;
                if(isLine) { lng=f.geometry.coordinates[0][0]; lat=f.geometry.coordinates[0][1]; }
                else { lng=f.geometry.coordinates[0]; lat=f.geometry.coordinates[1]; }
                for(let s of selectedStates) { const b = stateBounds[s]; if(lng>=b[0] && lat>=b[1] && lng<=b[2] && lat<=b[3]) return true; }
                return false;
            });
        }
        
        // --- Helper: find nearest Site for a given lon/lat within a distance tolerance ---
        function findNearestSiteForPoint(sites, lon, lat, toleranceMeters = 30) {
            if (!sites || !sites.length) return null;

            const R = 6371000; // Earth radius in meters
            let bestSite = null;
            let bestDist2 = Infinity;

            const toRad = d => d * Math.PI / 180;

            sites.forEach(site => {
                if (!site.geometry || !site.geometry.coordinates) return;
                const [sLon, sLat] = site.geometry.coordinates;

                const dLat = toRad(sLat - lat);
                const dLon = toRad(sLon - lon);
                const a =
                    Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                    Math.cos(toRad(lat)) * Math.cos(toRad(sLat)) *
                    Math.sin(dLon / 2) * Math.sin(dLon / 2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                const d = R * c; // distance in meters

                if (d < toleranceMeters && d * d < bestDist2) {
                    bestDist2 = d * d;
                    bestSite = site;
                }
            });

            return bestSite; // null if nothing within tolerance
        }

        function deriveSiteConnectivity(cables) {
            siteConnectivity = {}; 
            cables.forEach(c => {
                const p = c.properties;
                const name = p.NAME || '';
                if(name.length > 4 && (name.includes('BLS') || name.includes('XLS') || name.includes('ZLS'))) {
                    const siteCode = name.substring(0, 4).toUpperCase();
                    const u = p.LINK1; const v = p.LINK2;
                    const uExists = spliceLookup[u]; const vExists = spliceLookup[v];
                    let targetId = null;
                    if(uExists && !vExists) targetId = v;
                    else if (!uExists && vExists) targetId = u;
                    if(targetId) { if(!siteConnectivity[siteCode]) siteConnectivity[siteCode] = new Set(); siteConnectivity[siteCode].add(targetId); }
                }
            });
        }

        function mapSitesToConnectivity(sites) {
            // --- Stage 2: handle lead-in cables that connect two Sites directly ---
            allCables.forEach(cable => {
                const p = cable.properties || {};
                const name = p.NAME || '';
                const upName = name.toUpperCase();

                if (!(upName.includes('BLS') || upName.includes('XLS') || upName.includes('ZLS'))) {
                    return;
                }

                const u = p.LINK1;
                const v = p.LINK2;
                if (!u || !v) return;

                const uIsSplice = !!spliceLookup[u];
                const vIsSplice = !!spliceLookup[v];

                if (uIsSplice || vIsSplice) return; 

                const coords = cable.geometry && cable.geometry.coordinates;
                if (!coords || coords.length < 2) {
                    debugReport.push({
                        code: name,
                        assetType: 'Cable', // Added assetType
                        result: 'FAILED',
                        type: 'Site-Site Lead-in Match',
                        details: 'Cable has insufficient geometry to derive endpoints'
                    });
                    return;
                }

                const start = coords[0];
                const end   = coords[coords.length - 1];
                const [lon1, lat1] = start;
                const [lon2, lat2] = end;

                const site1 = findNearestSiteForPoint(sites, lon1, lat1, 30);
                const site2 = findNearestSiteForPoint(sites, lon2, lat2, 30);

                if (site1 && site2) {
                    const code1 = (site1.properties.SITE_CODE || '').toUpperCase();
                    const code2 = (site2.properties.SITE_CODE || '').toUpperCase();

                    if (!siteConnectivity[code1]) siteConnectivity[code1] = new Set();
                    if (!siteConnectivity[code2]) siteConnectivity[code2] = new Set();

                    siteConnectivity[code1].add(u);
                    siteConnectivity[code2].add(v);
                } else {
                    const missingEnds = [];
                    if (!site1) missingEnds.push('LINK1');
                    if (!site2) missingEnds.push('LINK2');
                    debugReport.push({
                        code: name,
                        assetType: 'Cable', // Added assetType
                        result: 'FAILED',
                        type: 'Site-Site Lead-in Match',
                        details: `Could not match ${missingEnds.join(' & ')} to any Site within tolerance`
                    });
                }
            });

            // --- Existing Site ID derivation ---
            sites.forEach(s => {
                const code = (s.properties.SITE_CODE || '').toUpperCase();
                const ids = siteConnectivity[code];

                if (ids && ids.size > 0) {
                    s.properties.LINKED_IDS = Array.from(ids);
                    s.properties.ID = s.properties.LINKED_IDS[0];
                } else {
                    s.properties.LINKED_IDS = [];
                    s.properties.ID = "UNLINKED";
                    debugReport.push({
                        code: code,
                        assetType: 'Site', // Added assetType
                        result: 'FAILED',
                        type: 'Topology Check',
                        details: 'No Lead-in cables found linked to this Site Code'
                    });
                }
            });

            return sites;
        }


        function resolveNodeSet(val) {
            const idOrCode = resolveId(val); 
            if(!idOrCode) return [];
            if(siteConnectivity[idOrCode]) return Array.from(siteConnectivity[idOrCode]);
            if(spliceLookup[idOrCode]) return [idOrCode];
            const site = allSites.find(s => s.properties.SITE_CODE === idOrCode);
            if(site && site.properties.LINKED_IDS && site.properties.LINKED_IDS.length > 0) return site.properties.LINKED_IDS;
            return [idOrCode];
        }

        // --- UPDATED REPORTING UI LOGIC ---

        function showDebugReport() {
            // Reset filters to defaults when opening
            document.getElementById('filterAsset').value = 'ALL';
            document.getElementById('filterStatus').value = 'ALL';
            document.getElementById('filterIssue').value = 'ALL';
            document.getElementById('filterText').value = '';
            
            filterDebugReport(); // Render the table
            document.getElementById('debugModal').classList.remove('hidden');
        }

        function filterDebugReport() {
            const tbody = document.getElementById('debugReportBody');
            const stats = document.getElementById('debugStats');
            
            // Get filter values
            const fAsset = document.getElementById('filterAsset').value;
            const fStatus = document.getElementById('filterStatus').value;
            const fIssue = document.getElementById('filterIssue').value;
            const fText = document.getElementById('filterText').value.toUpperCase().trim();

            tbody.innerHTML = '';

            // Filter the data
            const filtered = debugReport.filter(row => {
                if (fAsset !== 'ALL' && row.assetType !== fAsset) return false;
                if (fStatus !== 'ALL' && row.result !== fStatus) return false;
                if (fIssue !== 'ALL' && !row.type.includes(fIssue)) return false;
                if (fText.length > 0 && !row.code.includes(fText) && !row.details.toUpperCase().includes(fText)) return false;
                return true;
            });

            if(filtered.length === 0) {
                if(debugReport.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="5" class="p-4 text-center text-slate-400">No issues found. Network is healthy.</td></tr>';
                } else {
                    tbody.innerHTML = '<tr><td colspan="5" class="p-4 text-center text-slate-400">No records match current filters.</td></tr>';
                }
            } else {
                const reportSlice = filtered.slice(0, 500); // Pagination limit
                reportSlice.forEach(row => {
                    const color = row.result === 'FAILED' ? 'text-red-600 bg-red-50' : (row.result === 'WARNING' ? 'text-amber-600 bg-amber-50' : 'text-emerald-600');
                    
                    // Icon based on Asset Class
                    let icon = '<i class="fa-solid fa-circle-question text-slate-300"></i>';
                    if(row.assetType === 'Site') icon = '<i class="fa-solid fa-tower-cell text-teal-500"></i>';
                    if(row.assetType === 'Cable') icon = '<i class="fa-solid fa-bolt text-brand-500"></i>';
                    if(row.assetType === 'Splice') icon = '<i class="fa-solid fa-circle-dot text-purple-500"></i>';

                    tbody.innerHTML += `
                        <tr class="border-b border-slate-100 dark:border-slate-800 hover:bg-slate-50 dark:hover:bg-slate-800">
                            <td class="p-2 flex items-center gap-2 text-slate-500">${icon} <span class="font-bold">${row.assetType || 'Unknown'}</span></td>
                            <td class="p-2 font-bold select-all">${row.code}</td>
                            <td class="p-2"><span class="px-1.5 py-0.5 rounded text-[10px] font-bold ${color}">${row.result}</span></td>
                            <td class="p-2 text-[10px] font-medium">${row.type}</td>
                            <td class="p-2 text-[10px] text-slate-500 font-mono">${row.details}</td>
                        </tr>`;
                });
            }
            
            stats.innerHTML = `Showing <b class="text-slate-700 dark:text-white">${filtered.length}</b> of ${debugReport.length} records.`;
        }

        function copyDebugReport() { 
            // Copies the filtered view, not just everything
            const fAsset = document.getElementById('filterAsset').value;
            const fStatus = document.getElementById('filterStatus').value;
            const fIssue = document.getElementById('filterIssue').value;
            const fText = document.getElementById('filterText').value.toUpperCase().trim();

            const filtered = debugReport.filter(row => {
                if (fAsset !== 'ALL' && row.assetType !== fAsset) return false;
                if (fStatus !== 'ALL' && row.result !== fStatus) return false;
                if (fIssue !== 'ALL' && !row.type.includes(fIssue)) return false;
                if (fText.length > 0 && !row.code.includes(fText) && !row.details.toUpperCase().includes(fText)) return false;
                return true;
            });

            const text = "Asset\tID/Code\tResult\tIssue Type\tDetails\n" + 
                filtered.map(r => `${r.assetType || '-'}\t${r.code}\t${r.result}\t${r.type}\t${r.details}`).join('\n');
            
            navigator.clipboard.writeText(text).then(() => alert('Filtered report copied to clipboard!')); 
        }

        function indexNodes(list) { list.forEach(f => { const p = f.properties; if(p.ID) spliceLookup[p.ID] = f; if(p.NAME) nameToIdMap[p.NAME.trim()] = p.ID; if(p.SITE_CODE) nameToIdMap[p.SITE_CODE.trim()] = p.SITE_CODE; }); }
        function findRoot(i) { if(ufParent[i]===undefined) ufParent[i]=i; if(ufParent[i]!==i) ufParent[i]=findRoot(ufParent[i]); return ufParent[i]; }
        function unionSets(i,j) { const rI=findRoot(i), rJ=findRoot(j); if(rI!==rJ) ufParent[rI]=rJ; }
        // 1) UPDATED GRAPH BUILDER
        //    - Enforces HARD cable rules:
        //      * No cables whose NAME starts with "OF"
        //      * No cables whose NAME contains "ZLS" (leadâ€‘in ZLS banned)
        //      * No cables whose NAME contains "abandoned" (caseâ€‘insensitive)
        //      * PD and DF are now ALLOWED
        //    - Everything else unchanged.
        function buildGraph() {
            networkGraph = {}; 
            ufParent = {};

            allCables.forEach(c => {
                const p = c.properties;
                const u = p.LINK1, v = p.LINK2;
                if (!u || !v || u === v) return;

                const name = (p.NAME || "").toUpperCase();

                // HARD cable filters
                if (name.startsWith("OF")) return;          // 1. No OF* cables
                if (name.includes("ZLS")) return;          // 2. No ZLS leadâ€‘ins
                if (name.includes("ABANDONED")) return;    // 3. No "abandoned" cables
                // NOTE: PD / DF are explicitly allowed now â€“ no filter here.

                unionSets(u, v);
                const cost = Math.max(parseFloat(p.SPAN_LENGTH) || 10, 1);

                const edge = {
                    target: v,
                    cost,
                    cableId: p.ID,
                    cableName: p.NAME,
                    props: p
                };
                const rev = {
                    target: u,
                    cost,
                    cableId: p.ID,
                    cableName: p.NAME,
                    props: p
                };

                if (!networkGraph[u]) networkGraph[u] = [];
                if (!networkGraph[v]) networkGraph[v] = [];
                networkGraph[u].push(edge);
                networkGraph[v].push(rev);
            });
        }

        // --- NEW CONSTRAINT & UI LOGIC ---

        function handleModeChange() {
            updatePathInputs();
            constraintState = {}; 
            currentScopeId = '0';
            renderConstraintsUI();
        }

        function saveConstraintState() {
            const scope = currentScopeId;
            if(!constraintState[scope]) constraintState[scope] = {};
            
            const avoidC = document.getElementById('avoidCables');
            const incC = document.getElementById('includeCables');
            const avoidS = document.getElementById('avoidSplices');
            const incS = document.getElementById('includeSplices');
            
            if(avoidC) constraintState[scope].avoidCables = avoidC.value;
            if(incC) constraintState[scope].includeCables = incC.value;
            if(avoidS) constraintState[scope].avoidSplices = avoidS.value;
            if(incS) constraintState[scope].includeSplices = incS.value;
        }

        function switchConstraintTab(scope) {
            saveConstraintState();
            currentScopeId = scope;
            renderConstraintsUI();
        }

        function renderConstraintsUI() {
            const mode = document.getElementById('modeSelect').value;
            const container = document.getElementById('constraintsUI');
            const selector = document.getElementById('constraintSelector');
            
            // Stop propagation so clicking selector doesn't close accordion
            selector.onclick = (e) => e.stopPropagation();

            const vals = constraintState[currentScopeId] || { avoidCables:'', includeCables:'', avoidSplices:'', includeSplices:'' };

            // -- Selector Logic (Pills) --
            if(mode === 'single') {
                selector.innerHTML = '';
            } else if (mode === 'diverse') {
                selector.innerHTML = `
                    <div class="flex bg-slate-200/50 dark:bg-slate-700/50 rounded-lg p-0.5">
                        <div onclick="switchConstraintTab('0')" class="px-2 py-0.5 rounded-md text-[9px] font-bold cursor-pointer transition ${currentScopeId==='0' ? 'bg-white shadow-sm text-brand-600' : 'text-slate-500 hover:text-slate-700'}">Path 1</div>
                        <div onclick="switchConstraintTab('1')" class="px-2 py-0.5 rounded-md text-[9px] font-bold cursor-pointer transition ${currentScopeId==='1' ? 'bg-white shadow-sm text-emerald-600' : 'text-slate-500 hover:text-slate-700'}">Path 2</div>
                    </div>`;
            } else if (mode === 'ring') {
                const stops = document.querySelectorAll('.ring-stop');
                let options = '';
                for(let i=0; i<stops.length-1; i++) {
                    options += `<option value="${i}" ${currentScopeId==String(i)?'selected':''}>Leg ${i+1}</option>`;
                }
                if(options === '') options = `<option value="0">Leg 1</option>`;

                selector.innerHTML = `
                    <div class="relative bg-slate-100 dark:bg-slate-800 rounded-lg border border-slate-200 dark:border-slate-700 px-2 py-0.5">
                        <select onchange="switchConstraintTab(this.value)" class="bg-transparent border-none text-[9px] font-bold text-slate-600 dark:text-slate-300 p-0 pr-4 focus:ring-0 cursor-pointer">
                            ${options}
                        </select>
                    </div>`;
            }

            // -- Inputs Logic (Clean Fields) --
            const createField = (id, label, val, colorClass, icon) => `
                <div>
                    <label class="text-[9px] font-bold ${colorClass} uppercase mb-1 block flex items-center gap-1.5">
                        ${icon} ${label}
                    </label>
                    <div class="bg-slate-50 dark:bg-slate-800 border border-slate-200 dark:border-slate-700 rounded-lg px-2 py-1.5 focus-within:ring-1 focus-within:ring-brand-500 focus-within:border-brand-500 transition-all">
                        <input id="${id}" style="text-transform: uppercase;" class="w-full bg-transparent text-[10px] font-mono text-slate-700 dark:text-slate-300 placeholder-slate-400 outline-none" placeholder="Cable/Splice comma separated..." value="${val}">
                    </div>
                </div>
            `;

            container.innerHTML = `
                <div class="animate-fade-in grid grid-cols-1 gap-3">
                    ${createField('avoidCables', 'Avoid Cables', vals.avoidCables||'', 'text-slate-500', '<i class="fa-solid fa-slash"></i>')}
                    ${createField('includeCables', 'Must Include Cables', vals.includeCables||'', 'text-brand-600', '<i class="fa-solid fa-check-circle"></i>')}
                    ${createField('avoidSplices', 'Avoid Splices', vals.avoidSplices||'', 'text-slate-500', '<i class="fa-solid fa-slash"></i>')}
                    ${createField('includeSplices', 'Must Include Splices', vals.includeSplices||'', 'text-brand-600', '<i class="fa-solid fa-check-circle"></i>')}
                </div>
            `;
        }

        /* --- Route Panel Toggle Logic --- */
        function toggleRoutesPanel() {
            const wrapper = document.getElementById('routesContentWrapper');
            const icon = document.getElementById('routesToggleIcon');
            
            // Check if collapsed (using Tailwind classes)
            const isCollapsed = wrapper.classList.contains('max-h-0');

            if (isCollapsed) {
                // Expand
                wrapper.classList.remove('max-h-0', 'opacity-0');
                wrapper.classList.add('max-h-[60vh]', 'opacity-100');
                if(icon) icon.style.transform = 'rotate(0deg)';
            } else {
                // Collapse
                wrapper.classList.remove('max-h-[60vh]', 'opacity-100');
                wrapper.classList.add('max-h-0', 'opacity-0');
                // Rotate icon -90 degrees (pointing right)
                if(icon) icon.style.transform = 'rotate(-90deg)';
            }
        }

        // Helper to Force Expand (used when new results arrive)
        function expandRoutesPanel() {
            const wrapper = document.getElementById('routesContentWrapper');
            const icon = document.getElementById('routesToggleIcon');
            if(wrapper && wrapper.classList.contains('max-h-0')) {
                wrapper.classList.remove('max-h-0', 'opacity-0');
                wrapper.classList.add('max-h-[60vh]', 'opacity-100');
                if(icon) icon.style.transform = 'rotate(0deg)';
            }
        }

        /* --- UI Helper for Segmented Control --- */
        function setModeUI(mode) {
            // Visual update
            document.querySelectorAll('.segment-btn').forEach(b => b.classList.remove('active'));
            document.getElementById('seg-'+mode).classList.add('active');
            
            // Logic update
            const select = document.getElementById('modeSelect');
            select.value = mode;
            handleModeChange(); // Trigger existing logic
        }

        /* --- Update 1: updatePathInputs --- */
        function updatePathInputs() { 
            const mode = document.getElementById('modeSelect').value; 
            const div = document.getElementById('pathInputs'); 
            
            // Maintain values if re-rendering
            let valStart = '', valEnd = '';
            if(document.getElementById('pathStart')) valStart = document.getElementById('pathStart').value;
            if(document.getElementById('pathEnd')) valEnd = document.getElementById('pathEnd').value;
            
            const divCard = document.getElementById('divConstraintsCard');
            if (divCard) divCard.classList.add('hidden');

            if(mode === 'ring') {
                let stopsHTML = '';
                const existingStops = document.querySelectorAll('.ring-stop');
                if(existingStops.length > 0) {
                    existingStops.forEach((el, i) => {
                        const char = String.fromCharCode(65 + i);
                        stopsHTML += createStopInput(char, el.value, i);
                    });
                } else {
                    stopsHTML = createStopInput('A', valStart, 0) + createStopInput('B', valEnd, 1);
                }

                div.innerHTML = `
                    <div id="stopsContainer" class="space-y-3">${stopsHTML}</div>
                    <button type="button" onclick="addStopInput()" class="ml-[48px] text-[10px] font-bold text-brand-600 hover:text-brand-700 bg-brand-50 hover:bg-brand-100 border border-brand-200 rounded-lg px-3 py-1.5 transition flex items-center gap-1">
                        <i class="fa-solid fa-plus"></i> Add Hop
                    </button>`; 
            } else { 
                div.innerHTML = `
                <div class="glass-input-group flex items-center pl-2 pr-1 py-1">
                    <div class="w-8 h-8 rounded-lg bg-emerald-50 dark:bg-emerald-900/20 flex items-center justify-center shrink-0 border border-emerald-100 dark:border-emerald-900/30">
                        <i class="fa-solid fa-play text-emerald-500 text-[10px]"></i>
                    </div>
                    <div class="flex-1 min-w-0 ml-2">
                        <div class="float-label-group w-full">
                            <input
                                id="pathStart"
                                placeholder=" "
                                class="peer block w-full bg-transparent border border-slate-300 dark:border-slate-700 
                                    rounded-lg px-3.5 pb-2 pt-6 text-xs text-slate-800 dark:text-slate-200 
                                    focus:ring-1 focus:ring-brand-500 focus:border-brand-500 outline-none transition uppercase"
                            >
                            <label for="pathStart" class="float-label">Start Site / Splice</label>
                        </div>
                    </div>
                    <button type="button" class="w-7 h-7 flex items-center justify-center text-slate-400 hover:text-brand-600 hover:bg-slate-100 rounded-md transition" onclick="zoomToId('pathStart')">
                        <i class="fa-solid fa-crosshairs text-xs"></i>
                    </button>
                </div>

                <div class="glass-input-group flex items-center pl-2 pr-1 py-1">
                    <div class="w-8 h-8 rounded-lg bg-red-50 dark:bg-red-900/20 flex items-center justify-center shrink-0 border border-red-100 dark:border-red-900/30">
                        <i class="fa-solid fa-flag-checkered text-red-500 text-[10px]"></i>
                    </div>
                    <div class="flex-1 min-w-0 ml-2">
                        <div class="float-label-group w-full">
                            <input
                                id="pathEnd"
                                placeholder=" "
                                class="peer block w-full bg-transparent border border-slate-300 dark:border-slate-700 
                                    rounded-lg px-3.5 pb-2 pt-6 text-xs text-slate-800 dark:text-slate-200 
                                    focus:ring-1 focus:ring-brand-500 focus:border-brand-500 outline-none transition uppercase"
                            >
                            <label for="pathStart" class="float-label">End Site / Splice</label>
                        </div>
                    </div>
                    <button type="button" class="w-7 h-7 flex items-center justify-center text-slate-400 hover:text-brand-600 hover:bg-slate-100 rounded-md transition" onclick="zoomToId('pathEnd')">
                        <i class="fa-solid fa-crosshairs text-xs"></i>
                    </button>
                </div>`; 
            }
        }

        /* --- Update 2: createStopInput --- */
        function createStopInput(char, val, idx) {
            return `
                <div class="glass-input-group flex items-center pl-2 pr-1 py-1 animate-fade-in group">
                    <div class="w-8 h-8 rounded-lg bg-white dark:bg-slate-800 flex items-center justify-center shrink-0 border border-slate-200 dark:border-slate-700 shadow-sm z-10">
                        <span class="text-[10px] font-black text-slate-500">${char}</span>
                    </div>

                    <div class="flex-1 min-w-0 ml-2">
                        <div class="float-label-group w-full">
                            <input
                                id="stop${idx}"
                                style="text-transform: uppercase;"
                                placeholder=" "
                                value="${val || ''}"
                                class="peer ring-stop block w-full bg-transparent 
                                    border border-slate-300 dark:border-slate-700 
                                    rounded-lg px-3.5 pb-2 pt-6 
                                    text-xs font-bold text-slate-700 dark:text-slate-200 
                                    placeholder-transparent focus:ring-1 
                                    focus:ring-brand-500 focus:border-brand-500 
                                    outline-none transition"
                            >
                            <label for="stop${idx}" class="float-label">
                                Hop ${char}
                            </label>
                        </div>
                    </div>

                    <button
                        type="button"
                        class="w-7 h-7 flex items-center justify-center text-slate-400 hover:text-brand-600 hover:bg-slate-100 rounded-md transition"
                        onclick="zoomToId('stop${idx}')"
                    >
                        <i class="fa-solid fa-crosshairs text-xs"></i>
                    </button>

                    ${idx > 1
                        ? '<button type="button" class="w-7 h-7 flex items-center justify-center text-slate-300 hover:text-red-500 hover:bg-red-50 rounded-md transition" onclick="removeStop(this)"><i class="fa-solid fa-times text-xs"></i></button>'
                        : ''
                    }
                </div>`;
        }

        function addStopInput() { 
            const container = document.getElementById('stopsContainer');
            const count = document.querySelectorAll('.ring-stop').length;
            const char = String.fromCharCode(65 + count); 
            const div = document.createElement('div');
            div.innerHTML = createStopInput(char, '', count);
            container.appendChild(div.firstElementChild);
            renderConstraintsUI(); 
        }
        
        function removeStop(el) {
            el.parentElement.remove();
            const stops = [];
            document.querySelectorAll('.ring-stop').forEach(i => stops.push(i.value));
            const container = document.getElementById('stopsContainer');
            container.innerHTML = '';
            stops.forEach((val, i) => {
                const char = String.fromCharCode(65 + i);
                const d = document.createElement('div');
                d.innerHTML = createStopInput(char, val, i);
                container.appendChild(d.firstElementChild);
            });
            renderConstraintsUI();
        }

        function getHardConstraints(scopeId) {
            let vals;
            if (scopeId === currentScopeId) {
                vals = {
                    avoidCables: document.getElementById('avoidCables').value,
                    includeCables: document.getElementById('includeCables').value,
                    avoidSplices: document.getElementById('avoidSplices').value,
                    includeSplices: document.getElementById('includeSplices').value
                };
            } else {
                vals = constraintState[scopeId] || {};
            }

            const parseList = (str) => (!str ? [] : str.split(',').map(s => s.trim()).filter(s => s.length > 0));
            
            const constraints = { avoidEdges: new Set(), avoidNodes: new Set(), includeWaypoints: [] };
            
            parseList(vals.avoidCables).forEach(s => {
                const id = resolveId(s);
                if(id && cableLookup[id]) constraints.avoidEdges.add(id);
                if(cableSegmentsByName[s]) cableSegmentsByName[s].forEach(c => constraints.avoidEdges.add(c.properties.ID));
            });
            parseList(vals.avoidSplices).forEach(s => {
                const id = resolveId(s);
                if(id && spliceLookup[id]) constraints.avoidNodes.add(id);
            });
            parseList(vals.includeSplices).forEach(s => {
                const id = resolveId(s);
                if(id && spliceLookup[id]) constraints.includeWaypoints.push({ type: 'node', id: id, name: s });
            });
            parseList(vals.includeCables).forEach(s => {
                const id = resolveId(s);
                if(id && cableLookup[id]) constraints.includeWaypoints.push({ type: 'edge', id: id, name: s, obj: cableLookup[id] });
                else if (cableSegmentsByName[s]) {
                    constraints.includeWaypoints.push({ type: 'edge', id: cableSegmentsByName[s][0].properties.ID, name: s, obj: cableSegmentsByName[s][0] });
                }
            });
            return constraints;
        }

        function buildConstraintDetailsFromHardAndSoft(hard, softList, maxDistKm, scopeLabel) {
            const out = [];

            if (scopeLabel) {
                out.push({ k: 'Leg', v: scopeLabel });
            }

            if (hard) {
                if (hard.includeWaypoints && hard.includeWaypoints.length) {
                    out.push({
                        k: 'Must Include',
                        v: hard.includeWaypoints.map(w => w.name).join(', ')
                    });
                }
                if (hard.avoidEdges && hard.avoidEdges.size) {
                    out.push({
                        k: 'Avoid Cables',
                        v: `${hard.avoidEdges.size} selected`
                    });
                }
                if (hard.avoidNodes && hard.avoidNodes.size) {
                    out.push({
                        k: 'Avoid Splices',
                        v: `${hard.avoidNodes.size} selected`
                    });
                }
            }

            if (softList && softList.length) {
                out.push({
                    k: 'Soft Prefs',
                    v: softList.map(p => p.label).join(', ')
                });
            }

            if (maxDistKm && isFinite(maxDistKm) && maxDistKm !== Infinity) {
                out.push({
                    k: 'Max Distance',
                    v: maxDistKm.toFixed(1) + ' km'
                });
            }

            return out;
        }


        function checkConstraint(item, constr) {
            if(constr.type === 'edge') {
                if(constr.key === 'aerial' && item.props.CONSTRUCT_TYPE==='AR') return false;
                if(constr.key === 'new' && item.props.CABLE_STATUS==='PA') return false;
                if(constr.key === 'iof' && (item.props.IOF==='Y' || (item.cableName||'').match(/_AP|_MA|_SB|_SM/))) return false;
            } else if(constr.type === 'node') {
                const p = spliceLookup[item]?.properties;
                if(!p) return true; 
                if(p.SITE_CODE) return false; 
                if(constr.key && constr.key.startsWith('RS-') && p.RS_CODE === constr.key) return false;
                if(constr.key === 'citi' && ((p.MANHOLE||'').includes('CP_') || (p.RS_COMMENTS||'').includes('citi'))) return false;
            }
            return true;
        }

        // --- IMPROVED PATHFINDING ENGINE ---
                
        // Simple overlap by shared cable IDs (still used for de-duping single paths)
        function calculateOverlap(pathA, pathB) {
            let shared = 0;
            const setA = new Set(pathA.map(s => s.cableId));
            pathB.forEach(s => { if (setA.has(s.cableId)) shared++; });
            return shared / Math.min(pathA.length, pathB.length || 1);
        }

        // --- Geometry helpers for diversity scoring ---
        // Sample points along a path using cable geometry
        function getPathSamplePoints(segments, stepEvery = 4) {
            const pts = [];
            if (!segments) return pts;

            segments.forEach(seg => {
                let geoms = [];
                if (seg.cableName && cableSegmentsByName[seg.cableName]) {
                    geoms = cableSegmentsByName[seg.cableName];
                } else if (seg.cableId && cableSegmentsById[seg.cableId]) {
                    geoms = cableSegmentsById[seg.cableId];
                } else if (seg.cableId && cableLookup[seg.cableId]) {
                    geoms = [cableLookup[seg.cableId]];
                }

                geoms.forEach(g => {
                    if (!g || !g.geometry || !g.geometry.coordinates) return;

                    let coords = g.geometry.coordinates;
                    if (g.geometry.type === 'MultiLineString') {
                        // Flatten MultiLineString into a single array of [x,y]
                        coords = coords.flat();
                    }

                    for (let i = 0; i < coords.length; i += stepEvery) {
                        const c = coords[i];
                        if (!c || c.length < 2) continue;
                        pts.push({ x: c[0], y: c[1] });
                    }

                    // Always include the last point to capture endpoints
                    const last = coords[coords.length - 1];
                    if (last && last.length >= 2) {
                        pts.push({ x: last[0], y: last[1] });
                    }
                });
            });

            return pts;
        }

        // Approximate how geographically "close" two paths are.
        // Returns:
        //   ratio   = fraction of sampled points that are within ~10m of the other path
        //   minDist = minimum separation between the two paths in metres
        function computePathProximity(p1, p2) {
            const pts1 = getPathSamplePoints(p1.segments || [], 4);
            const pts2 = getPathSamplePoints(p2.segments || [], 4);

            if (pts1.length === 0 || pts2.length === 0) {
                return { ratio: 0, minDist: Infinity };
            }

            const THRESH_METRES = 10;       // "too close" threshold
            const SCALE = 100000;           // same rough scale as getDist()

            let close1 = 0;
            let close2 = 0;
            let globalMin = Infinity;

            // Helper: min distance from a point to a set of points (very rough but OK for ranking)
            function minDistToSet(a, set) {
                let best = Infinity;
                for (let i = 0; i < set.length; i++) {
                    const b = set[i];
                    const dx = a.x - b.x;
                    const dy = a.y - b.y;
                    const metres = Math.sqrt(dx * dx + dy * dy) * SCALE;
                    if (metres < best) best = metres;
                    if (metres < globalMin) globalMin = metres;
                }
                return best;
            }

            pts1.forEach(p => {
                const d = minDistToSet(p, pts2);
                if (d <= THRESH_METRES) close1++;
            });

            pts2.forEach(p => {
                const d = minDistToSet(p, pts1);
                if (d <= THRESH_METRES) close2++;
            });

            const r1 = close1 / pts1.length;
            const r2 = close2 / pts2.length;
            const ratio = Math.max(r1, r2);

            return { ratio, minDist: globalMin };
        }

        // --- Exact cable-crossing detection for diversity ranking ---

        // --- Exact cable-crossing detection for diversity ranking ---

        // Build simple 2D line segments for all cables used by a path.
        // NOTE: we cache the result on the path object so we don't
        // re-build geometry for every pairwise comparison.
        function getPathLineSegmentsForPath(pathObj) {
            if (!pathObj) return [];

            // Cached?
            if (pathObj._lineSegs) return pathObj._lineSegs;

            const segs = [];
            let minX = Infinity, minY = Infinity;
            let maxX = -Infinity, maxY = -Infinity;

            if (!pathObj.segments) {
                pathObj._lineSegs = [];
                pathObj._bbox = null;
                return pathObj._lineSegs;
            }

            pathObj.segments.forEach(seg => {
                let geoms = [];

                if (seg.cableName && cableSegmentsByName[seg.cableName]) {
                    geoms = cableSegmentsByName[seg.cableName];
                } else if (seg.cableId && cableSegmentsById[seg.cableId]) {
                    geoms = cableSegmentsById[seg.cableId];
                } else if (seg.cableId && cableLookup[seg.cableId]) {
                    geoms = [cableLookup[seg.cableId]];
                }

                const cableMeta = (seg.cableId && cableLookup[seg.cableId]) || {};
                const name = cableMeta.NAME || cableMeta.name || seg.cableName || seg.name || '';
                const isLeadIn = isLeadInCableName(name);
                const id = seg.cableId || cableMeta.ID || name;

                geoms.forEach(g => {
                    if (!g || !g.geometry || !g.geometry.coordinates) return;

                    let coords = g.geometry.coordinates;
                    if (g.geometry.type === 'MultiLineString') {
                        coords = coords.flat();
                    }

                    for (let i = 0; i < coords.length - 1; i++) {
                        const a = coords[i];
                        const b = coords[i + 1];
                        if (!a || !b || a.length < 2 || b.length < 2) continue;

                        const x1 = a[0], y1 = a[1];
                        const x2 = b[0], y2 = b[1];

                        segs.push({
                            x1, y1, x2, y2,
                            cableId: id,
                            isLeadIn
                        });

                        if (x1 < minX) minX = x1;
                        if (x2 < minX) minX = x2;
                        if (y1 < minY) minY = y1;
                        if (y2 < minY) minY = y2;
                        if (x1 > maxX) maxX = x1;
                        if (x2 > maxX) maxX = x2;
                        if (y1 > maxY) maxY = y1;
                        if (y2 > maxY) maxY = y2;
                    }
                });
            });

            // Cache on the path object
            pathObj._lineSegs = segs;
            pathObj._bbox = (segs.length > 0)
                ? { minX, minY, maxX, maxY }
                : null;

            return segs;
        }

        function segmentsIntersect2D(s1, s2) {
            const x1 = s1.x1, y1 = s1.y1, x2 = s1.x2, y2 = s1.y2;
            const x3 = s2.x1, y3 = s2.y1, x4 = s2.x2, y4 = s2.y2;

            // Quick bounding-box reject
            if (Math.max(x1, x2) < Math.min(x3, x4) ||
                Math.max(x3, x4) < Math.min(x1, x2) ||
                Math.max(y1, y2) < Math.min(y3, y4) ||
                Math.max(y3, y4) < Math.min(y1, y2)) {
                return false;
            }

            function orient(ax, ay, bx, by, cx, cy) {
                return (bx - ax) * (cy - ay) - (by - ay) * (cx - ax);
            }

            const o1 = orient(x1, y1, x2, y2, x3, y3);
            const o2 = orient(x1, y1, x2, y2, x4, y4);
            const o3 = orient(x3, y3, x4, y4, x1, y1);
            const o4 = orient(x3, y3, x4, y4, x2, y2);

            const EPS = 1e-9;

            function onSegment(ax, ay, bx, by, cx, cy) {
                return cx >= Math.min(ax, bx) - EPS && cx <= Math.max(ax, bx) + EPS &&
                    cy >= Math.min(ay, by) - EPS && cy <= Math.max(ay, by) + EPS;
            }

            // General case
            if (((o1 > 0 && o2 < 0) || (o1 < 0 && o2 > 0)) &&
                ((o3 > 0 && o4 < 0) || (o3 < 0 && o4 > 0))) {
                return true;
            }

            // Colinear / touching cases
            if (Math.abs(o1) < EPS && onSegment(x1, y1, x2, y2, x3, y3)) return true;
            if (Math.abs(o2) < EPS && onSegment(x1, y1, x2, y2, x4, y4)) return true;
            if (Math.abs(o3) < EPS && onSegment(x3, y3, x4, y4, x1, y1)) return true;
            if (Math.abs(o4) < EPS && onSegment(x3, y3, x4, y4, x2, y2)) return true;

            return false;
        }

        // Count cable crossings between two paths.
        //  - total  = geometric crossings that are *not* at a shared node
        //  - lead   = crossings where both segments are lead-in cables
        // --- [UPDATE FUNCTION] countPathCrossings ---
        function countPathCrossings(p1, p2) {
            const segs1 = getPathLineSegmentsForPath(p1);
            const segs2 = getPathLineSegmentsForPath(p2);
            // [MODIFIED] Return object now includes points array
            const result = { total: 0, lead: 0, points: [] }; 

            if (segs1.length === 0 || segs2.length === 0) return result;

            const samePoint = (x1, y1, x2, y2) => Math.abs(x1 - x2) < 1e-7 && Math.abs(y1 - y2) < 1e-7;

            for (let i = 0; i < segs1.length; i++) {
                const a = segs1[i];
                for (let j = 0; j < segs2.length; j++) {
                    const b = segs2[j];
                    if (a.cableId && b.cableId && a.cableId === b.cableId) continue;

                    // [MODIFIED] Use new intersection helper
                    const pt = getIntersectionPoint(a, b);
                    
                    if (pt) {
                        // Check if it's just a shared endpoint (node connection)
                        const endpointTouch =
                            samePoint(a.x1, a.y1, b.x1, b.y1) || samePoint(a.x1, a.y1, b.x2, b.y2) ||
                            samePoint(a.x2, a.y2, b.x1, b.y1) || samePoint(a.x2, a.y2, b.x2, b.y2);

                        if (endpointTouch) continue;

                        result.total++;
                        const isLead = (a.isLeadIn && b.isLeadIn); // Check your existing isLeadIn logic
                        if (isLead) result.lead++;
                        
                        // [NEW] Capture the location
                        result.points.push({ 
                            lat: pt.y, lng: pt.x, 
                            type: isLead ? 'lead-cross' : 'cross' 
                        });
                    }
                }
            }
            return result;
        }


        // --- Helpers: derive nodeIds / edgeIds from a path (segments array) ---
        function getNodeIdsFromSegments(segments) {
            const nodeIds = new Set();
            if (!segments) return nodeIds;

            segments.forEach(seg => {
                if (seg.from !== undefined && seg.from !== null) {
                    nodeIds.add(seg.from);
                }
                if (seg.target !== undefined && seg.target !== null) {
                    nodeIds.add(seg.target);
                }
            });
            return nodeIds;
        }

        function getEdgeIdsFromSegments(segments) {
            const edgeIds = new Set();
            if (!segments) return edgeIds;

            segments.forEach(seg => {
                if (seg.cableId) edgeIds.add(seg.cableId);
            });
            return edgeIds;
        }

        // --- Lead-in helpers for chain / ring scoring ---
        function isLeadInCableName(name) {
            if (!name) return false;
            const up = String(name).toUpperCase();
            // Treat BLS / XLS / ZLS as lead-in naming pattern
            return up.includes('BLS') || up.includes('XLS') || up.includes('ZLS');
        }

        /**
         * Extract lead-in cable IDs at the start and end of a path/leg.
         * Returns { startLeadId, endLeadId } â€“ either value can be null.
         */
        function extractLeadInIds(pathObj) {
            const result = { startLeadId: null, endLeadId: null };
            if (!pathObj || !pathObj.segments || !pathObj.segments.length) return result;

            const segs = pathObj.segments;

            // Scan from the front for first lead-in-looking cable
            for (let i = 0; i < segs.length; i++) {
                const s = segs[i];
                const cableMeta = cableLookup[s.cableId] || {};
                const name = cableMeta.NAME || cableMeta.name || s.cableName || s.name;
                if (isLeadInCableName(name)) {
                    result.startLeadId = s.cableId || null;
                    break;
                }
            }

            // Scan from the back for last lead-in-looking cable
            for (let i = segs.length - 1; i >= 0; i--) {
                const s = segs[i];
                const cableMeta = cableLookup[s.cableId] || {};
                const name = cableMeta.NAME || cableMeta.name || s.cableName || s.name;
                if (isLeadInCableName(name)) {
                    result.endLeadId = s.cableId || null;
                    break;
                }
            }

            return result;
        }

        // [HELPER] Missing helper required for Updated A* code above
        function checkNodePassable(nodeId, unused) { return true; }
        
        // --- UPDATED A* ENGINE (With Anti-Freeze Circuit Breaker) ---

        // 1. Simple A* (Used for Fallback)
        function runSimpleBidirectionalAStar(startNodes, endNodes, priorityList, hardConstraints, extraExclusions = {}, maxDist = Infinity) {
            const fwd = new BinaryHeap(n => n.f), bwd = new BinaryHeap(n => n.f);
            const fDist = {}, bDist = {}, fPrev = {}, bPrev = {}, fVis = new Set(), bVis = new Set();
            const startSet = new Set(startNodes);
            const endSet   = new Set(endNodes);

            // [FIX] Circuit breaker constants
            let ops = 0;
            const MAX_OPS = 50000; 

            startNodes.forEach(s => { fDist[s] = 0; fwd.push({ id: s, f: 0 }); });
            endNodes.forEach(e => { bDist[e] = 0; bwd.push({ id: e, f: 0 }); });

            const baseEdges = hardConstraints.avoidEdges || new Set();
            const baseNodes = hardConstraints.avoidNodes || new Set();
            const exclE = new Set([...(extraExclusions.edges || []), ...baseEdges]);
            const exclN = new Set([...(extraExclusions.nodes || []), ...baseNodes]);

            while (fwd.size() > 0 && bwd.size() > 0) {
                // [FIX] Check operation count
                ops++;
                if(ops > MAX_OPS) return null; // Abort if search takes too long

                // Forward step
                if (fwd.size() > 0) {
                    const u = fwd.pop().id;
                    if (fDist[u] > maxDist) continue;
                    if (!fVis.has(u)) {
                        fVis.add(u);
                        if (bVis.has(u) && fDist[u] + bDist[u] <= maxDist) {
                            return reconstructBidirectionalPath(fPrev, bPrev, u, startSet, endSet);
                        }
                        if (networkGraph[u]) for (const e of networkGraph[u]) {
                            if (exclE.has(e.cableId) || exclN.has(e.target)) continue;

                            let passable = true;
                            for (let c of priorityList) {
                                if (c.type === 'edge' && !checkConstraint(e, c)) { passable = false; break; }
                                if (c.type === 'node' && !checkConstraint(e.target, c)) { passable = false; break; }
                            }
                            if (!passable) continue;
                            if (!startSet.has(u) && !checkNodePassable(e.target, null) && !endSet.has(e.target)) continue;

                            const w = e.cost;
                            const alt = fDist[u] + w;
                            if (fDist[e.target] === undefined || alt < fDist[e.target]) {
                                fDist[e.target] = alt;
                                fPrev[e.target] = { e, from: u };
                                fwd.push({ id: e.target, f: alt });
                            }
                        }
                    }
                }

                // Backward step
                if (bwd.size() > 0) {
                    const u = bwd.pop().id;
                    if (bDist[u] > maxDist) continue;
                    if (!bVis.has(u)) {
                        bVis.add(u);
                        if (fVis.has(u) && fDist[u] + bDist[u] <= maxDist) {
                            return reconstructBidirectionalPath(fPrev, bPrev, u, startSet, endSet);
                        }
                        if (networkGraph[u]) for (const e of networkGraph[u]) {
                            if (exclE.has(e.cableId) || exclN.has(e.target)) continue;

                            let passable = true;
                            for (let c of priorityList) {
                                if (c.type === 'edge' && !checkConstraint(e, c)) { passable = false; break; }
                                if (c.type === 'node' && !checkConstraint(e.target, c)) { passable = false; break; }
                            }
                            if (!passable) continue;
                            if (!endSet.has(u) && !checkNodePassable(e.target, null) && !startSet.has(e.target)) continue;

                            const w = e.cost;
                            const alt = bDist[u] + w;
                            if (bDist[e.target] === undefined || alt < bDist[e.target]) {
                                bDist[e.target] = alt;
                                bPrev[e.target] = { e, from: u };
                                bwd.push({ id: e.target, f: alt });
                            }
                        }
                    }
                }
            }
            return null;
        }

        // Fallback candidate generator based on strict edge exclusion per candidate
        async function generateAllPathCandidatesFallback(starts, ends, priorityList, hardConstraints, maxDist, limitPerPair = 3) {
            const results = [];
            const sList = Array.isArray(starts) ? starts : [starts];
            const eList = Array.isArray(ends) ? ends : [ends];

            for (let sId of sList) {
                for (let eId of eList) {
                    if (sId === eId) continue;

                    let exclusions = {
                        edges: Array.from(hardConstraints.avoidEdges || []),
                        nodes: Array.from(hardConstraints.avoidNodes || [])
                    };

                    for (let k = 0; k < limitPerPair; k++) {
                        const segs = runSimpleBidirectionalAStar([sId], [eId], priorityList, hardConstraints, exclusions, maxDist || Infinity);
                        if (!segs) break;

                        const len = getPathLength(segs);
                        if (maxDist && isFinite(maxDist) && len > maxDist) break;

                        const edgeIds = new Set(segs.map(s => s.cableId));
                        edgeIds.forEach(id => exclusions.edges.push(id));

                        results.push({
                            startId: sId,
                            endId: eId,
                            segments: segs,
                            edgeIds,
                            length: len
                        });
                    }
                }
            }

            results.sort((a, b) => a.length - b.length);
            return results;
        }


        // 2) NEW HELPER â€“ "INCLUDE" LIST MUST ALL BE SATISFIED
        //    constraints.includeWaypoints is an array of objects:
        //      { type: 'edge'|'node', id: <ID>, name, obj }
        //    This function returns true only if *all* required items
        //    are actually present on the path.
        function pathSatisfiesInclusions(path, includeWaypoints) {
            if (!includeWaypoints || includeWaypoints.length === 0) return true;

            const edgeIds = new Set(path.map(seg => seg.cableId));
            const nodeIds = new Set();
            path.forEach(seg => {
                if (seg.from !== undefined) nodeIds.add(seg.from);
                if (seg.target !== undefined) nodeIds.add(seg.target);
            });

            for (const wp of includeWaypoints) {
                if (wp.type === 'edge') {
                    if (!edgeIds.has(wp.id)) return false; // required cable not on path
                } else if (wp.type === 'node') {
                    if (!nodeIds.has(wp.id)) return false; // required splice not on path
                }
            }
            return true;
        }

        // --- UPDATED MAIN ORCHESTRATOR ---
        async function findPath() {
            saveConstraintState(); 
            const mode = document.getElementById('modeSelect').value;
            
            let rawStops = [];
            if(mode === 'ring') document.querySelectorAll('.ring-stop').forEach(i => { if(i.value) rawStops.push(i.value); });
            else rawStops = [document.getElementById('pathStart').value, document.getElementById('pathEnd').value];

            const stopSets = rawStops.map(val => resolveNodeSet(val));
            if(stopSets.some(s => s.length === 0)) { alert("Invalid ID/Name. Please select valid assets."); return; }
            if(!networkGraph) { alert("No network data loaded."); return; }
            
            const priorityList = getActiveConstraints();
            const maxDist = (parseFloat(document.getElementById('maxDist').value) || Infinity) * 1000;
            const divConst = getDiversitySettings(); 

            solutionSets = []; foundPaths = [];
            
            // [NEW] Timer Initialization
            const startTime = performance.now();
            const timerEl = document.getElementById('searchTimer');
            if(timerEl) timerEl.innerText = "0.00s";
            
            const timerInterval = setInterval(() => {
                if(timerEl) {
                    const now = performance.now();
                    timerEl.innerText = ((now - startTime) / 1000).toFixed(2) + "s";
                }
            }, 100);

            // Initialize UI
            document.getElementById('loadingOverlay').classList.remove('hidden');
            updateSearchProgress(5, "Initializing graph engine...");
            
            endpointLayer.clearLayers();
            rawStops.forEach(val => {
                const id = resolveId(val); 
                let stopNode = spliceLookup[id];
                if(!stopNode && siteConnectivity[id]) stopNode = spliceLookup[Array.from(siteConnectivity[id])[0]];
                if(stopNode) {
                    L.marker([stopNode.geometry.coordinates[1], stopNode.geometry.coordinates[0]], {
                        icon: L.divIcon({className: 'bg-transparent', html: `<div class="w-3 h-3 bg-blue-600 rounded-full border-2 border-white shadow-md"></div>`})
                    }).addTo(endpointLayer).bindTooltip(val, { permanent: true, direction: 'top', className: 'endpoint-label', offset: [0, -5] });
                }
            });

            await new Promise(r => setTimeout(r, 100)); // Slight delay for UI render

            try {
                // ==========================================
                // MODE: SINGLE
                // ==========================================
                if (mode === 'single') {
                    const constraints = getHardConstraints('0');
                    
                    const candidates = await generatePathCandidates(
                        stopSets[0],
                        stopSets[1],
                        priorityList,
                        constraints,
                        maxDist,
                        10,
                        (found, limit, iter, isFallback) => {
                            const base = 10; 
                            const range = 80;
                            const pct = base + ((found / limit) * range);
                            const msg = isFallback 
                                ? `Running strict fallback search... (${found}/${limit})` 
                                : `Finding unique variations... Found ${found}`;
                            updateSearchProgress(pct, msg);
                        }
                    );

                    updateSearchProgress(95, "Finalizing route details...");

                    if (candidates.length > 0) {
                        candidates.forEach((p, i) => {
                            const km = (p.length / 1000).toFixed(2);
                            solutionSets.push({
                                id: i,
                                label: `Option ${i + 1}`,
                                meta: `Length: ${km} km`,
                                details: [
                                    { k: 'Length', v: km + ' km' },
                                    { k: 'Segments', v: p.segments.length }
                                ],
                                paths: [{ segments: p.segments, color: '#ef4444', label: 'Primary' }]
                            });
                        });
                    } else {
                        const details = buildConstraintDetailsFromHardAndSoft(constraints, priorityList, maxDist / 1000, null);
                        solutionSets.push({ id: 0, label: 'Error: No route found', meta: 'Check connectivity constraints', details, paths: [], isError: true });
                    }
                }

                // ==========================================
                // MODE: DIVERSE
                // ==========================================
                else if(mode === 'diverse') {
                    const const1 = getHardConstraints('0');
                    const const2 = getHardConstraints('1');
                    const POOL_SIZE = 12;

                    // Step 1: Route A
                    const pool1 = await generatePathCandidates(
                        stopSets[0], stopSets[1], priorityList, const1, maxDist, POOL_SIZE,
                        (found, limit) => updateSearchProgress(10 + (found/limit)*30, `Routing Primary Paths... (${found} vars)`)
                    );

                    // Step 2: Route B
                    const pool2 = await generatePathCandidates(
                        stopSets[0], stopSets[1], priorityList, const2, maxDist, POOL_SIZE,
                        (found, limit) => updateSearchProgress(40 + (found/limit)*30, `Routing Secondary Paths... (${found} vars)`)
                    );
                    
                    // Step 3: Analysis
                    updateSearchProgress(80, `Analyzing ${pool1.length * pool2.length} combinations...`);
                    await new Promise(r => setTimeout(r, 20)); 

                    const allPairs = findCrossDiversePairs(pool1, pool2, divConst, 50);
                    updateSearchProgress(90, `Ranking ${allPairs.length} pairs by diversity...`);
                    
                    if(allPairs.length > 0) {
                        allPairs.forEach((pair, i) => {
                            const totalKm = ((pair.p1.length + pair.p2.length)/1000).toFixed(1);
                            const cross = pair.stats.crossings || 0;
                            solutionSets.push({
                                id: i,
                                label: `Option ${i+1} <span class="tier-tag ${pair.tierClass}">${pair.tierLabel}</span>`,
                                meta: `Shared: ${pair.stats.edges} Cabl / ${pair.stats.nodes} Node â€¢ Cross: ${cross}`,
                                details: [
                                    { k: 'Shared Cables',  v: pair.stats.edges, c: pair.stats.edges>0?'text-red-600 font-bold':'' },
                                    { k: 'Shared Nodes',   v: pair.stats.nodes, c: pair.stats.nodes>0?'text-orange-600 font-bold':'' },
                                    { k: 'Crossings',      v: cross,            c: cross>0?'text-purple-600 font-bold':'' },
                                    { k: 'Total Length',   v: totalKm+' km' },
                                    { k: 'Lead-ins',       v: pair.stats.leadIn ? 'Shared' : 'Diverse', c: pair.stats.leadIn?'text-red-500':'' }
                                ],
                                paths: [
                                    { segments: pair.p1.segments, color:'#ef4444', label:'Primary Path' },
                                    { segments: pair.p2.segments, color:'#22c55e', label:'Diverse Pair' }
                                ]
                            });
                        });
                    } else {
                        const details = buildConstraintDetailsFromHardAndSoft(const1, priorityList, maxDist / 1000, null);
                        solutionSets.push({ id: 0, label: 'No Pairs Found', meta: 'Single path available only', details, paths: [], isError: true });
                    }
                }

                // ==========================================
                // MODE: RING / MULTI-HOP
                // ==========================================
                else if(mode === 'ring') {
                    let legsCandidates = [];
                    let brokenLegIndex = -1;
                    const legCount = stopSets.length - 1;
                    
                    // [OPTIMIZATION FIX] Reduced limit from 12 to 5 for Ring Mode
                    // This prevents combinatorial explosion and "stuck" searches on later legs
                    const RING_LEG_LIMIT = 5; 

                    for(let i=0; i<legCount; i++) {
                        const legLabel = `Leg ${i+1}/${legCount}`;
                        const legConst = getHardConstraints(String(i)); 
                        
                        const startPct = 10 + (i / legCount) * 70;
                        const endPct = 10 + ((i + 1) / legCount) * 70;

                        const cands = await generatePathCandidates(
                            stopSets[i], 
                            stopSets[i+1], 
                            priorityList, 
                            legConst, 
                            maxDist, 
                            RING_LEG_LIMIT, // Use optimized limit
                            (found, limit) => {
                                const legProgress = (found/limit);
                                const totalPct = startPct + (legProgress * (endPct - startPct));
                                updateSearchProgress(totalPct, `Optimizing ${legLabel}: Finding variations (${found})...`);
                            }
                        );
                        
                        if(cands.length === 0) { 
                            brokenLegIndex = i;
                            break; 
                        }
                        legsCandidates.push(cands);
                        await new Promise(r => setTimeout(r, 10));
                    }

                    if(brokenLegIndex !== -1) {
                        const details = buildConstraintDetailsFromHardAndSoft(getHardConstraints(String(brokenLegIndex)), priorityList, maxDist / 1000, `Leg ${brokenLegIndex+1}`);
                        solutionSets.push({ id: 0, label: `Error: Broken at Leg ${brokenLegIndex + 1}`, meta: 'Check connectivity', details, paths: [], isError: true });
                    } else {
                        updateSearchProgress(85, "Stitching ring topology...");
                        const chains = findTopRingChains(legsCandidates, divConst, 50);
                        updateSearchProgress(95, `Found ${chains.length} valid topologies...`);
                        
                        const LEG_COLORS = ['#ef4444', '#22c55e', '#f59e0b', '#a855f7', '#3b82f6', '#ec4899', '#06b6d4'];

                        if(chains.length > 0) {
                            chains.forEach((chain, i) => {
                                const paths = chain.chain.map((leg, lIdx) => ({
                                    segments: leg.segments,
                                    color: LEG_COLORS[lIdx % LEG_COLORS.length], 
                                    label: `Leg ${lIdx+1}`
                                }));
                                const km = (chain.totalLen/1000).toFixed(1);
                                const cross = chain.stats?.crossings || 0;
                                solutionSets.push({ 
                                    id: i, 
                                    label: `Option ${i+1} <span class="tier-tag ${chain.tierClass}">${chain.tierLabel}</span>`, 
                                    meta: `${km} km â€¢ ${cross} crossings`,
                                    details: [
                                        { k: 'Total Length',  v: km+' km' },
                                        { k: 'Edge Overlap',  v: chain.overlap > 0 ? chain.overlap + ' Segs' : 'None', c: chain.overlap>0?'text-red-600 font-bold':'' },
                                        { k: 'Crossings',     v: cross,    c: cross>0?'text-purple-600 font-bold':'' }
                                    ],
                                    paths: paths 
                                });
                            });
                        }
                    }
                }
            } catch(e) { 
                console.error(e); 
                alert("Search error: " + e.message); 
            } finally {
                // [NEW] Stop Timer & Save Total Time
                clearInterval(timerInterval);
                const endTime = performance.now();
                const totalDuration = ((endTime - startTime) / 1000).toFixed(2);

                updateSearchProgress(100, `Completed in ${totalDuration}s`);
                setTimeout(() => {
                    document.getElementById('loadingOverlay').classList.add('hidden');
                    if(solutionSets.length > 0) { 
                        // Pass the total time to the renderer
                        renderSolutionSelector(totalDuration); 
                        switchSolution(0); 
                    }
                }, 400);
            }
        }
        // 4) UPDATED CANDIDATE GENERATION
        //    - Still returns multiple nearâ€‘optimal paths using penalty reâ€‘runs.
        //    - NEW: enforces that *all* includeWaypoints are present on the path.
        // --- Main candidate generator: penalty-based + strict fallback ---
        // --- UPDATED CANDIDATE GENERATOR (With Progress Feedback) ---
        async function generatePathCandidates(starts, ends, priorityList, constraints, maxDist, limit, progressCallback) {
            
            // Get threshold from UI
            const simSlider = document.getElementById('pathSimilaritySlider');
            const similarityThreshold = simSlider ? (parseInt(simSlider.value) / 100) : 0.9;

            let candidates = [];
            let penalties = new Map(); // Map<cableId, penaltyMultiplier>

            // 1) Penalty-based engine
            // We loop up to 4x the limit to try and force diverse paths via penalties
            const maxIterations = limit * 4;

            for (let k = 0; k < maxIterations; k++) {
                
                // Report progress back to UI if callback provided
                if (progressCallback) {
                    progressCallback(candidates.length, limit, k);
                }

                let path = await runBidirectionalAStar(starts, ends, priorityList, constraints, Infinity, penalties);

                if (!path) break; // exhausted connectivity

                const length = getPathLength(path);
                
                // Only enforce maxDist if physically set (otherwise we allow logic to filter later)
                if (maxDist && isFinite(maxDist) && length > maxDist) {
                    break;
                }

                // Check Inclusion Constraints
                let satisfiesInclusions = true;
                if (constraints.includeWaypoints && constraints.includeWaypoints.length > 0 && typeof pathSatisfiesInclusions === "function") {
                    if (!pathSatisfiesInclusions(path, constraints.includeWaypoints)) {
                        satisfiesInclusions = false;
                    }
                }

                // Dupe / similarity check
                let isDuplicate = false;
                if (satisfiesInclusions) {
                    for (let existing of candidates) {
                        const overlap = calculateOverlap(path, existing.segments);
                        if (overlap > similarityThreshold) { 
                            isDuplicate = true;
                            break;
                        }
                    }
                }

                // Apply penalties to this path's cables so next iteration looks elsewhere
                path.forEach(seg => {
                    const id = seg.cableId;
                    if (!id) return;
                    const prev = penalties.get(id) || 0;
                    // Higher penalty = stronger repulsion next time
                    penalties.set(id, prev + 1.0);
                });

                if (satisfiesInclusions && !isDuplicate) {
                    const edgeIds = getEdgeIdsFromSegments(path);
                    const nodeIds = getNodeIdsFromSegments(path);

                    candidates.push({
                        segments: path,
                        length,
                        edgeIds,
                        nodeIds,
                        leadIn:  path[0] ? path[0].cableId : null,
                        leadOut: path.length > 0 ? path[path.length - 1].cableId : null,
                        tierLabel: "Distinct",
                        tierClass: "tier-gold"
                    });
                    
                    // Allow the UI to breathe slightly
                    await new Promise(r => setTimeout(r, 5));
                }

                if (candidates.length >= limit) break;
            }

            if (candidates.length > 0) {
                candidates.sort((a, b) => a.length - b.length);
                return candidates.slice(0, limit);
            }

            // 2) Fallback to strict engine if penalty engine failed
            if (progressCallback) progressCallback(0, limit, 0, true); // Signal fallback mode
            return await generateAllPathCandidatesFallback(starts, ends, priorityList, constraints, maxDist, limit);
        }

        // --- Fallback generator: strict edge-exclusion per candidate ---
        // This mimics the older "working good" behaviour and is used when
        // the penalty-based engine cannot find enough candidates.
        async function generateAllPathCandidatesFallback(starts, ends, priorityList, constraints, maxDist, limitPerPair = 3) {
            let results = [];

            const sList = Array.isArray(starts) ? starts : [starts];
            const eList = Array.isArray(ends) ? ends : [ends];

            // Base avoid sets from constraints (hard constraints)
            const baseAvoidEdges = new Set(constraints.avoidEdges || []);
            const baseAvoidNodes = new Set(constraints.avoidNodes || []);

            for (let sId of sList) {
                for (let eId of eList) {
                    if (sId === eId) continue;

                    // Local, per-pair exclusion set
                    let currentAvoidEdges = new Set(baseAvoidEdges);
                    let pathsFoundForPair = 0;

                    while (pathsFoundForPair < limitPerPair) {
                        // Build a local constraints object for this iteration
                        const localConstraints = {
                            ...constraints,
                            avoidEdges: currentAvoidEdges,
                            avoidNodes: baseAvoidNodes
                        };

                        // Run A* WITHOUT penalties and WITHOUT maxDist limiting (weâ€™ll
                        // check real length after)
                        const path = await runBidirectionalAStar(
                            [sId],
                            [eId],
                            priorityList,
                            localConstraints,
                            Infinity,
                            null
                        );

                        if (!path) break;

                        const realLength = getPathLength(path);
                        if (maxDist && isFinite(maxDist) && realLength > maxDist) {
                            // No point continuing; further ones will be longer
                            break;
                        }

                        const edgeIds = getEdgeIdsFromSegments(path);
                        const nodeIds = getNodeIdsFromSegments(path);

                        results.push({
                            startId: sId,
                            endId: eId,
                            segments: path,
                            length: realLength,
                            edgeIds,
                            nodeIds,
                            leadIn:  path[0] ? path[0].cableId : null,
                            leadOut: path.length > 0 ? path[path.length - 1].cableId : null,
                            tierLabel: "Distinct",
                            tierClass: "tier-gold"
                        });

                        // Strict diversity: forbid all edges in this path for the next iteration
                        path.forEach(seg => {
                            if (seg.cableId) currentAvoidEdges.add(seg.cableId);
                        });

                        pathsFoundForPair++;
                    }
                }
            }

            results.sort((a, b) => a.length - b.length);
            return results;
        }

        function findCrossDiversePairs(pool1, pool2, divSettings, limit) {
            let pairs = [];
            const MAX_RESULTS = limit || 50;

            // Penalties for crossings between paths
            const CROSSING_PENALTY   = 1000000; // treat backbone crossings ~ as bad as shared cable
            const LEAD_CROSS_PENALTY = 150000;  // much softer when *only* lead-ins cross

            // Track which (pathA, pathB) combinations we've already seen.
            // Key is order-independent so (A,B) and (B,A) collapse to the same key.
            const seenPairs = new Set();

            // Pre-compute edge/node sets and edge-key for each candidate to avoid
            // repeating work inside the nested loops.
            const pool1Prepared = pool1.map(p => {
                const edges = (p.edgeIds instanceof Set)
                    ? p.edgeIds
                    : getEdgeIdsFromSegments(p.segments || []);
                const nodes = (p.nodeIds instanceof Set)
                    ? p.nodeIds
                    : getNodeIdsFromSegments(p.segments || []);
                const edgeKey = Array.from(edges).sort().join(',');
                return { p, edges, nodes, edgeKey };
            });

            const pool2Prepared = pool2.map(p => {
                const edges = (p.edgeIds instanceof Set)
                    ? p.edgeIds
                    : getEdgeIdsFromSegments(p.segments || []);
                const nodes = (p.nodeIds instanceof Set)
                    ? p.nodeIds
                    : getNodeIdsFromSegments(p.segments || []);
                const edgeKey = Array.from(edges).sort().join(',');
                return { p, edges, nodes, edgeKey };
            });

            pool1Prepared.forEach(({ p: p1, edges: p1Edges, nodes: p1Nodes, edgeKey: k1 }) => {
                pool2Prepared.forEach(({ p: p2, edges: p2Edges, nodes: p2Nodes, edgeKey: k2 }) => {
                    // Skip pair where both paths are literally the same cable set
                    if (k1 === k2) return;

                    // Order-independent pair key so (A,B) and (B,A) are treated as one
                    const pairKey = k1 <= k2 ? `${k1}||${k2}` : `${k2}||${k1}`;
                    if (seenPairs.has(pairKey)) return;
                    seenPairs.add(pairKey);

                    let sharedEdges = 0;
                    let sharedNodes = 0;

                    let conflicts = []; // [NEW] Array to store issues

                    // 1. Capture Shared Edges (Cables)
                    for (let e of p1Edges) {
                        if (p2Edges.has(e)) {
                            sharedEdges++;
                            // [NEW] Find geometry for this edge
                            const cable = cableLookup[e];
                            if(cable) conflicts.push({ type: 'shared-cable', geometry: cable.geometry });
                        }
                    }

                    // 2. Capture Shared Nodes
                    for (let n of p1Nodes) {
                        if (p2Nodes.has(n)) {
                            sharedNodes++;
                            // [NEW] Find geometry for this node
                            const node = spliceLookup[n] || (allSites.find(s=>s.properties.SITE_CODE===n));
                            if(node) conflicts.push({ 
                                type: 'shared-node', 
                                lat: node.geometry.coordinates[1], 
                                lng: node.geometry.coordinates[0],
                                id: n 
                            });
                        }
                    }

                    const sameLeadIn  = p1.leadIn === p2.leadIn;
                    const sameLeadOut = p1.leadOut === p2.leadOut;

                    // Geometric corridor proximity (0 = far apart, 1 = almost identical corridor)
                    const geo = computePathProximity(p1, p2);
                    const closeRatio = geo.ratio;   // fraction of points within ~10m
                    const minGeoDist = geo.minDist; // metres

                    // Exact cable crossings (lead-in vs backbone)
                    let crossInfo = { total: 0, lead: 0, points: [] };
                    if (sharedEdges === 0) {
                        crossInfo = countPathCrossings(p1, p2);
                        // [NEW] Add crossing points to conflicts
                        if(crossInfo.points) conflicts.push(...crossInfo.points);
                    }
                    const totalCrossings = crossInfo.total;
                    const leadCrossings  = crossInfo.lead;
                    const backboneCross  = Math.max(0, totalCrossings - leadCrossings);

                    // Scoring: lower is better
                    let score =
                        (sharedEdges * 1000000) +
                        (sharedNodes * 100000) +
                        (backboneCross * CROSSING_PENALTY) +
                        (leadCrossings * LEAD_CROSS_PENALTY) +
                        ((sameLeadIn ? 1 : 0) * 50000) +
                        ((sameLeadOut ? 1 : 0) * 50000) +
                        (Math.round(closeRatio * 800000)) +   // corridor overlap penalty
                        ((minGeoDist < 10 ? 200000 : 0)) +    // hard penalty if paths physically touch/cross
                        (p1.length + p2.length);              // finally, total length

                    // Tiering
                    let tierLabel = "High Diversity";
                    let tierClass = "tier-gold";

                    if (sharedEdges > 0) {
                        tierLabel = "Fibre Overlap";
                        tierClass = "tier-fail";
                    } else if (sharedNodes > 0) {
                        tierLabel = "Node Overlap";
                        tierClass = "tier-bronze";
                    } else if (backboneCross > 0) {
                        // Separate cables but they physically intersect â€“ treat as diversity violation
                        tierLabel = "Cable Crossing";
                        tierClass = "tier-silver";
                    } else if (closeRatio > 0.5 || minGeoDist < 10) {
                        // Different cables but effectively same trench / corridor
                        tierLabel = "Same Corridor";
                        tierClass = "tier-silver";
                    } else if (sameLeadIn || sameLeadOut) {
                        tierLabel = "Shared Lead-in";
                        tierClass = "tier-silver";
                    }

                    pairs.push({
                        p1,
                        p2,
                        score,
                        tierLabel,
                        tierClass,
                        conflicts: conflicts, // <--- PASS THIS TO UI
                        stats: {
                            edges: sharedEdges,
                            nodes: sharedNodes,
                            leadIn: (sameLeadIn || sameLeadOut),
                            geomClose: closeRatio,
                            minDist: isFinite(minGeoDist) ? Math.round(minGeoDist) : null,
                            crossings: totalCrossings,
                            leadCrossings: leadCrossings
                        }
                    });
                });
            });

            pairs.sort((a, b) => a.score - b.score);
            return pairs.slice(0, MAX_RESULTS);
        }

        // --- Ring / Daisy-chain scoring with geometric diversity + crossings ---
        function findTopRingChains(legsCandidates, divSettings, limit) {
            const combinations = [];
            const legsCount = legsCandidates.length;

            // Allow more variants per leg so we can find â€œweird but diverseâ€ combos
            const MAX_PER_LEG = 9;                 // was 7
            const MAX_RESULTS = limit || 50;

            // Score a full chain (one candidate per leg)
            function scoreRingChain(chain) {
                let totalLen = 0;          // in metres
                let overlapEdges = 0;
                let overlapNodes = 0;
                let worstGeoRatio = 0;
                let minGeoDist = Infinity;
                let sharedLeadsMid = 0;    // count of â€œsame lead-inâ€ reuse at intermediate sites

                let totalCrossings = 0;    // NEW: all cable crossings across legs
                let leadCrossings  = 0;    // NEW: subset where both segments are lead-ins

                const allEdges = new Set();
                const allNodes = new Set();

                // --- Accumulate length, overlap, geometry and crossings between legs ---
                for (let i = 0; i < chain.length; i++) {
                    const leg = chain[i];

                    totalLen += leg.length || 0;

                    const edges = (leg.edgeIds instanceof Set)
                        ? leg.edgeIds
                        : getEdgeIdsFromSegments(leg.segments || []);

                    const nodes = (leg.nodeIds instanceof Set)
                        ? leg.nodeIds
                        : getNodeIdsFromSegments(leg.segments || []);

                    // Edge overlap across legs
                    edges.forEach(e => {
                        if (allEdges.has(e)) overlapEdges++;
                        allEdges.add(e);
                    });

                    // Node overlap across legs
                    nodes.forEach(n => {
                        if (allNodes.has(n)) overlapNodes++;
                        allNodes.add(n);
                    });

                    // Geometric proximity & crossings vs all later legs
                    for (let j = i + 1; j < chain.length; j++) {
                        const other = chain[j];

                        const geo = computePathProximity(leg, other); // { ratio, minDist }
                        if (geo.ratio > worstGeoRatio) worstGeoRatio = geo.ratio;
                        if (geo.minDist < minGeoDist) minGeoDist = geo.minDist;

                        const cross = countPathCrossings(leg, other);
                        totalCrossings += cross.total;
                        leadCrossings  += cross.lead;
                    }
                }

                // --- Lead-in reuse at intermediate sites (multi-lead-in issue) ---
                for (let i = 0; i < chain.length - 1; i++) {
                    const legA = chain[i];
                    const legB = chain[i + 1];

                    const leadsA = extractLeadInIds(legA); // { startLeadId, endLeadId }
                    const leadsB = extractLeadInIds(legB); // { startLeadId, endLeadId }

                    if (leadsA && leadsB &&
                        leadsA.endLeadId && leadsB.startLeadId &&
                        leadsA.endLeadId === leadsB.startLeadId) {

                        // Leg i exits and leg i+1 enters via the same lead-in
                        sharedLeadsMid++;
                    }
                }

                // Normalise length to km so diversity penalties dominate
                const totalLenKm = totalLen / 1000;

                // ---- Weights (tuned for â€œdiversity first, length secondâ€) ----
                const EDGE_OVERLAP_PENALTY   = 10000000;  // fibres shared between legs
                const NODE_OVERLAP_PENALTY   =  2000000;  // joints shared between legs
                const GEO_CORRIDOR_WEIGHT    =  2000000;  // geometric corridor overlap
                const GEO_TOUCH_PENALTY      =  1000000;  // legs physically touching / very close
                const LEAD_REUSE_PENALTY     =   400000;  // same lead-in used at mid-site

                // NEW: crossings â€“ treat backbone crossings ~shared cable, but soften lead-in-only
                const CROSSING_PENALTY       = EDGE_OVERLAP_PENALTY;
                const LEAD_CROSS_PENALTY     =   300000;  // much lighter than backbone cross

                const backboneCross = Math.max(0, totalCrossings - leadCrossings);

                const LEN_WEIGHT             =        1;  // km scale so 10 km diff = +10

                const score =
                    (overlapEdges * EDGE_OVERLAP_PENALTY) +
                    (overlapNodes * NODE_OVERLAP_PENALTY) +
                    (backboneCross * CROSSING_PENALTY) +
                    (leadCrossings * LEAD_CROSS_PENALTY) +
                    Math.round(worstGeoRatio * GEO_CORRIDOR_WEIGHT) +
                    ((minGeoDist < 10) ? GEO_TOUCH_PENALTY : 0) +
                    (sharedLeadsMid * LEAD_REUSE_PENALTY) +
                    (totalLenKm * LEN_WEIGHT);

                // Tiering for UI
                let tierLabel = "Diverse Ring";
                let tierClass = "tier-gold";

                if (overlapEdges > 0) {
                    tierLabel = "Fibre Overlap";
                    tierClass = "tier-fail";
                } else if (overlapNodes > 0) {
                    tierLabel = "Node Overlap";
                    tierClass = "tier-bronze";
                } else if (backboneCross > 0) {
                    // They don't share a fibre, but cables actually intersect
                    tierLabel = "Cable Crossing";
                    tierClass = "tier-silver";
                } else if (worstGeoRatio > 0.5 || minGeoDist < 10) {
                    // Different fibres but effectively same trench / crossing / corridor
                    tierLabel = "Same Corridor";
                    tierClass = "tier-silver";
                } else if (sharedLeadsMid > 0) {
                    // Fully separate in the backbone but sharing an intermediate lead-in
                    tierLabel = "Shared Lead-in";
                    tierClass = "tier-silver";
                }

                return {
                    chain: chain.slice(),        // keep a copy
                    totalLen,
                    overlap: overlapEdges,
                    tierLabel,
                    tierClass,
                    score,
                    stats: {
                        edges: overlapEdges,
                        nodes: overlapNodes,
                        geomClose: worstGeoRatio,
                        minDist: isFinite(minGeoDist) ? Math.round(minGeoDist) : null,
                        sharedLeads: sharedLeadsMid,
                        crossings: totalCrossings,
                        leadCrossings: leadCrossings
                    }
                };
            }

            // Depth-first search over leg combinations (with per-leg candidate cap)
            function search(legIdx, currentChain) {
                if (legIdx >= legsCount) {
                    combinations.push(scoreRingChain(currentChain));
                    return;
                }

                const legCandidates = legsCandidates[legIdx] || [];
                const take = Math.min(legCandidates.length, MAX_PER_LEG);

                for (let i = 0; i < take; i++) {
                    currentChain.push(legCandidates[i]);
                    search(legIdx + 1, currentChain);
                    currentChain.pop();
                }
            }

            search(0, []);

            combinations.sort((a, b) => a.score - b.score);
            return combinations.slice(0, MAX_RESULTS);
        }


        // --- CORE A* with PENALTIES ---
        // 3) UPDATED BIDIRECTIONAL A* SEARCH
        //    - Respects avoidEdges / avoidNodes (as before)
        //    - Respects soft preferences via checkConstraintsList (as before)
        //    - Adds HARD rule: a path cannot *pass through* a Site node
        //      (SITE_CODE set) â€“ sites are allowed only as endpoints.

        // 2. Main Penalty A* (Used for Primary Search)
        function runBidirectionalAStar(startNodes, endNodes, priorityList, constraints, maxDist, penaltyMap) {
            const fwd = new BinaryHeap(n => n.f), bwd = new BinaryHeap(n => n.f);
            const fDist = {}, bDist = {}, fPrev = {}, bPrev = {}, fVis = new Set(), bVis = new Set();
            const startSet = new Set(startNodes);
            const endSet   = new Set(endNodes);
            const exclE = constraints.avoidEdges;
            const exclN = constraints.avoidNodes;
            const SOFT_AVOID_PENALTY = 50000; 

            // [FIX] Circuit breaker constants
            let ops = 0;
            const MAX_OPS = 60000; // Slightly higher for penalty search

            startNodes.forEach(s => { fDist[s] = 0; fwd.push({ id: s, f: 0 }); });
            endNodes.forEach(e => { bDist[e] = 0; bwd.push({ id: e, f: 0 }); });

            while (fwd.size() > 0 && bwd.size() > 0) {
                // [FIX] Check operation count
                ops++;
                if(ops > MAX_OPS) return null;

                // FORWARD SEARCH STEP
                if (fwd.size() > 0) {
                    const u = fwd.pop().id;
                    if (fDist[u] > maxDist) continue;

                    const propsU = spliceLookup[u]?.properties;
                    if (propsU && propsU.SITE_CODE && !startSet.has(u) && !endSet.has(u)) continue; 

                    if (!fVis.has(u)) {
                        fVis.add(u);
                        if (bVis.has(u)) {
                            if (fDist[u] + bDist[u] <= maxDist)
                                return reconstructBidirectionalPath(fPrev, bPrev, u, startSet, endSet);
                        }
                        if (networkGraph[u]) {
                            for (const e of networkGraph[u]) {
                                if (exclE.has(e.cableId) || exclN.has(e.target)) continue;

                                let hardBlock = false;
                                let softPenalty = 0;
                                for (let c of priorityList) {
                                    let isViolation = false;
                                    if (c.type === 'edge' && !checkConstraint(e, c)) isViolation = true;
                                    if (c.type === 'node' && !checkConstraint(e.target, c)) isViolation = true; // Fixed target check
                                    if (isViolation) {
                                        if (c.isStrict) { hardBlock = true; break; } 
                                        else { softPenalty += SOFT_AVOID_PENALTY; }
                                    }
                                }
                                if (hardBlock) continue;

                                let diversityPenalty = 1;
                                if (penaltyMap && penaltyMap.has(e.cableId)) diversityPenalty += penaltyMap.get(e.cableId);

                                const stepCost = (e.cost * diversityPenalty) + softPenalty;
                                const alt = fDist[u] + stepCost;

                                if (fDist[e.target] === undefined || alt < fDist[e.target]) {
                                    fDist[e.target] = alt;
                                    fPrev[e.target] = { ...e, from: u };
                                    fwd.push({ id: e.target, f: alt + getDist(e.target, endNodes[0]) });
                                }
                            }
                        }
                    }
                }

                // BACKWARD SEARCH STEP
                if (bwd.size() > 0) {
                    const v = bwd.pop().id;
                    if (bDist[v] > maxDist) continue;

                    const propsV = spliceLookup[v]?.properties;
                    if (propsV && propsV.SITE_CODE && !startSet.has(v) && !endSet.has(v)) continue;

                    if (!bVis.has(v)) {
                        bVis.add(v);
                        if (fVis.has(v)) {
                            if (fDist[v] + bDist[v] <= maxDist)
                                return reconstructBidirectionalPath(fPrev, bPrev, v, startSet, endSet);
                        }
                        if (networkGraph[v]) {
                            for (const e of networkGraph[v]) {
                                if (exclE.has(e.cableId) || exclN.has(e.target)) continue;

                                let hardBlock = false;
                                let softPenalty = 0;
                                for (let c of priorityList) {
                                    let isViolation = false;
                                    if (c.type === 'edge' && !checkConstraint(e, c)) isViolation = true;
                                    if (c.type === 'node' && !checkConstraint(e.target, c)) isViolation = true;
                                    if (isViolation) {
                                        if (c.isStrict) { hardBlock = true; break; }
                                        else { softPenalty += SOFT_AVOID_PENALTY; }
                                    }
                                }
                                if (hardBlock) continue;

                                let diversityPenalty = 1;
                                if (penaltyMap && penaltyMap.has(e.cableId)) diversityPenalty += penaltyMap.get(e.cableId);

                                const stepCost = (e.cost * diversityPenalty) + softPenalty;
                                const alt = bDist[v] + stepCost;

                                if (bDist[e.target] === undefined || alt < bDist[e.target]) {
                                    bDist[e.target] = alt;
                                    bPrev[e.target] = { ...e, from: v };
                                    bwd.push({ id: e.target, f: alt + getDist(e.target, startNodes[0]) });
                                }
                            }
                        }
                    }
                }
            }
            return null; 
        }
        
        function reconstructBidirectionalPath(fwdPrev, bwdPrev, meetingNode, startSet, endSet) {
            const path = []; let curr = meetingNode; const fwdPart = []; 
            while(!startSet.has(curr)) { const edge = fwdPrev[curr]; if(!edge) break; fwdPart.push(edge); curr = edge.from; }
            for (let i = fwdPart.length - 1; i >= 0; i--) path.push(fwdPart[i]);
            curr = meetingNode;
            while(!endSet.has(curr)) { const edge = bwdPrev[curr]; if(!edge) break; path.push({ from: curr, target: edge.from, cost: edge.cost, cableId: edge.cableId, cableName: edge.cableName }); curr = edge.from; }
            return path;
        }

        function getDist(idA, idB) { const a = spliceLookup[idA], b = spliceLookup[idB]; if (!a || !b) return 0; const c1 = a.geometry.coordinates, c2 = b.geometry.coordinates; return Math.sqrt(Math.pow(c1[0]-c2[0], 2) + Math.pow(c1[1]-c2[1], 2)) * 100000; }
        function getPathLength(path) { return path.reduce((sum, step) => { if(step.cableName && cableSegmentsByName[step.cableName]) return sum + cableSegmentsByName[step.cableName].reduce((s,f)=>s+(parseFloat(f.properties.SPAN_LENGTH)||0),0); return sum + step.cost; }, 0); }
        function renderPriorityList() {
            const c = document.getElementById('priorityList');
            c.innerHTML = '';
            // Header for the list
            c.innerHTML += `<div class="flex justify-between text-[9px] text-slate-400 font-bold px-2 mb-1"><span>CONSTRAINT</span><span>STRICT</span></div>`;
            DEFAULT_PRIORITIES.forEach(p => {
                const isDefault = (p.id === 'rs-no');   // only RS-NO is ticked initially

                c.innerHTML += `
                    <div class="draggable-item flex items-center gap-2 bg-white dark:bg-slate-800 p-2 rounded-md border border-slate-100 dark:border-slate-700 text-[10px] shadow-sm mb-1 group hover:border-brand-200" data-id="${p.id}" data-type="${p.type}" data-key="${p.key || p.code}">
                        <i class="fa-solid fa-grip-vertical text-slate-300"></i>
                        <input type="checkbox" class="priority-chk accent-brand-600 w-3 h-3 rounded" ${isDefault ? 'checked' : ''}>
                        <span class="flex-1 font-medium text-slate-600 dark:text-slate-300 truncate">${p.label}</span>
                        <label class="flex items-center gap-1 cursor-pointer">
                            <input type="checkbox" class="strict-chk accent-red-500 w-3 h-3 rounded">
                        </label>
                    </div>`;
            });

            new Sortable(c, { animation: 150 });
        }
        function renderDiversityList() { const c = document.getElementById('diversityList'); c.innerHTML=''; DEFAULT_DIVERSITY.forEach(p => { c.innerHTML+=`<div class="draggable-item flex items-center gap-2 bg-white dark:bg-slate-900 p-2 rounded-md border border-slate-100 dark:border-slate-700 text-[10px] shadow-sm" data-id="${p.id}"><i class="fa-solid fa-grip-vertical text-slate-300"></i><input type="checkbox" class="diversity-chk accent-brand-600 w-3 h-3 rounded" checked><span class="flex-1 font-medium text-brand-700 dark:text-brand-400 truncate">${p.label}</span></div>`; }); new Sortable(c, { animation: 150 }); }
        function toggleAllPriorities(cb) { document.querySelectorAll('.priority-chk').forEach(c => c.checked = cb.checked); }
        function getActiveConstraints() { 
            const active = []; 
            document.querySelectorAll('#priorityList .draggable-item').forEach((el, idx) => { 
                if(el.querySelector('.priority-chk').checked) {
                    active.push({ 
                        type: el.dataset.type, 
                        key: el.dataset.key, 
                        label: el.innerText,
                        // NEW: Capture strict status
                        isStrict: el.querySelector('.strict-chk').checked 
                    }); 
                }
            }); 
            return active; 
        }

        function getDiversitySettings() { const active = {}; document.querySelectorAll('#diversityList .draggable-item').forEach((el) => { if(el.querySelector('.diversity-chk').checked) active[el.dataset.id] = true; }); return active; }
        function resolveId(v) { if(!v) return null; v=v.trim(); return spliceLookup[v]?v : nameToIdMap[v] || nameToIdMap[v.toUpperCase()]; }
        function setVal(id, val) { 
            let displayVal = val;
            const asset = spliceLookup[val] || cableLookup[val];
            if(asset) { if(asset.properties.NAME) displayVal = asset.properties.NAME; else if(asset.properties.SITE_CODE) displayVal = asset.properties.SITE_CODE; }
            document.getElementById(id).value = displayVal; 
            switchTab('pathfinder'); 
            map.closePopup(); 
            if(id.startsWith('stop')) renderConstraintsUI();
        }
        function getCableStyle(f) { const p=f.properties; let c='#2563eb', w=2, o=0.8, d=null; if(p.CABLE_STATUS==='PA') c='#10b981'; else if(p.CABLE_STATUS==='PD') { c='#94a3b8'; o=0.4; } else if((p.NAME||'').match(/BLS|XLS/)) c='#d97706'; if(p.CONSTRUCT_TYPE==='AR') { w=2; d='4,6'; } return { color:c, weight:w, opacity:o, dashArray:d }; }
        function createSpliceMarker(f,l) { return L.circleMarker(l, { radius:2, fillColor:f.properties.RESTRICTED==='Y'?'#ef4444':'#9333ea', color:'#fff', weight:1, opacity:1, fillOpacity:1 }); }
        function createSiteMarker(f,l) { return L.circleMarker(l, { radius:4, fillColor:'#14b8a6', color:'#fff', weight:1, opacity:1, fillOpacity:1 }); }
        function onEachCable(f,l) { layerLookup[f.properties.ID] = l; }
        function onEachSplice(f,l) { layerLookup[f.properties.ID] = l; }
        function onEachSite(f,l) { layerLookup[f.properties.ID] = l; }
        function onEachPathSegment(f,l) { l.on('mouseover', function(){this.setStyle({weight:8})}); l.on('mouseout', function(){this.setStyle({weight:f.properties.active?6:4})}); }
        function switchTab(t) { document.querySelectorAll('.tab-btn').forEach(b => { b.classList.remove('border-brand-600','text-brand-700','dark:text-brand-400'); b.classList.add('border-transparent'); }); event.target.classList.remove('border-transparent'); event.target.classList.add('border-brand-600','text-brand-700','dark:text-brand-400'); document.getElementById('tab-browser').classList.add('hidden'); const pf = document.getElementById('tab-pathfinder'); pf.classList.add('hidden'); pf.classList.remove('flex'); document.getElementById('tab-'+t).classList.remove('hidden'); if(t === 'pathfinder') document.getElementById('tab-pathfinder').classList.add('flex'); }
        function renderSidebar() { const list = document.getElementById('assetList'); const term = document.getElementById('searchInput').value.toLowerCase(); const frag = document.createDocumentFragment(); let count = 0; const limit = 50; for(let i=0; i<allSites.length && count<limit; i++) { const s = allSites[i].properties; if(!term || (s.SITE_CODE||'').toLowerCase().includes(term) || (s.ID||'').includes(term)) { frag.appendChild(createItem(s, 'site')); count++; } } for(let i=0; i<allSplices.length && count<limit*2; i++) { const s = allSplices[i].properties; if(!term || (s.NAME||'').toLowerCase().includes(term) || (s.ID||'').includes(term)) { frag.appendChild(createItem(s, 'splice')); count++; } } for(let i=0; i<allCables.length && count<limit*3; i++) { const c = allCables[i].properties; if(!term || (c.NAME||'').toLowerCase().includes(term) || (c.ID||'').includes(term)) { frag.appendChild(createItem(c, 'cable')); count++; } } list.innerHTML = ''; list.appendChild(frag); }
        function createItem(p, type) { const el = document.createElement('div'); let icon = type==='cable'?'<i class="fa-solid fa-bolt text-brand-600"></i>':(type==='splice'?'<i class="fa-solid fa-circle-dot text-purple-600"></i>':'<i class="fa-solid fa-tower-cell text-teal-600"></i>'); el.className = "flex items-center gap-3 p-2.5 hover:bg-slate-100 dark:hover:bg-slate-800 rounded-lg cursor-pointer text-xs border border-transparent hover:border-slate-200 dark:hover:border-slate-700 transition"; el.innerHTML = `<div class="w-7 h-7 flex items-center justify-center bg-white dark:bg-slate-800 rounded-md border border-slate-200 shadow-sm">${icon}</div><div class="flex-1 min-w-0"><div class="truncate font-bold text-slate-700 dark:text-slate-200">${p.NAME||p.SITE_CODE}</div><div class="text-[9px] text-slate-400 font-mono truncate">${p.ID}</div></div>`; el.onclick = () => { const layer = layerLookup[p.ID]; if(layer) { if(layer.getBounds) map.fitBounds(layer.getBounds(), {padding:[50,50], maxZoom:16}); else { map.setView(layer.getLatLng(), 18); layer.openPopup(); } } }; return el; }
        function updateStats(){ document.getElementById('stat-cable').innerText = allCables.length; document.getElementById('stat-splice').innerText = allSplices.length; document.getElementById('stat-site').innerText = allSites.length; let km=0; allCables.forEach(c=>km+=parseFloat(c.properties.SPAN_LENGTH)||0); document.getElementById('stat-km').innerText = (km/1000).toFixed(0); }

        function exportPathCSV() {
            // Prefer Splice NAME, then SITE_CODE, then raw ID
            const formatNode = (id) => {
                if (!id) return '';
                const f = spliceLookup[id];
                if (!f || !f.properties) return id;
                const p = f.properties;
                return p.NAME || p.SITE_CODE || id;
            };

            // New header:
            // From before Cable, To after Cable, then Length + Total Length, extra columns, VMR link at end
            let csv = "Path,Leg,Seq,From,Cable,To,Length,Total Length,RS_CODE,RS_COMMENT,IOF,New Cable,VMR Link\n";

            foundPaths.forEach((pathObj, pIdx) => {
                let totalLen = 0;
                const pathLabel = pathObj.label.replace(/<[^>]*>?/gm, '');

                pathObj.segments.forEach((s, i) => {
                    if (!s || !s.cableId) return;

                    // Cable meta
                    const cableFeat = cableLookup[s.cableId];
                    const cProps = cableFeat ? cableFeat.properties : (s.props || {});
                    const segLen = Math.round(
                        parseFloat(cProps.SPAN_LENGTH) || s.cost || 0
                    );
                    totalLen += segLen;

                    // From / To using Splice Name or Site Code
                    const fromLabel = formatNode(s.from);
                    const toLabel   = formatNode(s.target);

                    // To-node RS info
                    const toProps   = (s.target && spliceLookup[s.target] && spliceLookup[s.target].properties) || {};
                    const rsCode    = toProps.RS_CODE    || "";
                    const rsComment = toProps.RS_COMMENTS || "";

                    // IOF flag (Y if IOF or IOF-style name)
                    const name   = cProps.NAME || s.cableName || "";
                    const isIOF  = (cProps.IOF === 'Y') || /_AP|_MA|_SB|_SM/.test(name);
                    const iofFlg = isIOF ? 'Y' : '';

                    // New Cable flag (Y if status PA)
                    const newFlg = cProps.CABLE_STATUS === 'PA' ? 'Y' : '';

                    // VMR link from SEGMENT_ID
                    const segId   = cProps.SEGMENT_ID || "";
                    const vmrLink = segId
                        ? `https://cadprdwebw001.optus.com.au/vmr/CrossSectionReview.aspx?id=${segId}`
                        : "";

                    // Note:
                    // - Leg column now uses pIdx+1 so multi-leg solutions are distinguishable
                    // - Length = segment length, Total Length = cumulative for this leg
                    csv += `"${pathLabel}",${pIdx + 1},${i + 1},` +
                        `"${fromLabel}","${s.cableName || s.cableId}","${toLabel}",` +
                        `${segLen},${totalLen},` +
                        `"${rsCode}","${rsComment}","${iofFlg}","${newFlg}","${vmrLink}"\n`;
                });
            });

            const a = document.createElement('a');
            a.href = URL.createObjectURL(new Blob([csv], { type: 'text/csv' }));
            a.download = 'path.csv';
            a.click();
        }


        function zoomToId(id) { 
            const val = document.getElementById(id).value;
            // Try to resolve the ID/Name, otherwise fallback to the raw uppercase input
            const v = resolveId(val) || (val ? val.trim().toUpperCase() : null); 

            if(!v) return;

            // 1. Check Splices
            if(spliceLookup[v]) { 
                const s = spliceLookup[v];
                map.setView([s.geometry.coordinates[1], s.geometry.coordinates[0]], 18); 
                if(s._layer) s._layer.openPopup();
                return;
            }

            // 2. Check Sites (This was missing)
            const site = allSites.find(s => s.properties.SITE_CODE === v || s.properties.ID === v);
            if(site) {
                map.setView([site.geometry.coordinates[1], site.geometry.coordinates[0]], 18);
                // Sites update their ID to LINKED_IDS[0] during processing, so we check layerLookup using that properties.ID
                if(site.properties.ID && layerLookup[site.properties.ID]) {
                    layerLookup[site.properties.ID].openPopup();
                }
                return;
            }

            // 3. Check Cables (Optional, but helpful)
            if(cableLookup[v] && layerLookup[v]) {
                map.fitBounds(layerLookup[v].getBounds(), {padding:[100,100]});
                return;
            }

            // Fallback: Check if it's a raw Site Code that wasn't resolved
            const rawSite = allSites.find(s => s.properties.SITE_CODE === val.toUpperCase());
            if(rawSite) {
                 map.setView([rawSite.geometry.coordinates[1], rawSite.geometry.coordinates[0]], 18);
                 if(rawSite.properties.ID && layerLookup[rawSite.properties.ID]) layerLookup[rawSite.properties.ID].openPopup();
            }
        }

        function highlightPathSegment(cableId, name) { pathLayer.eachLayer(layer => { if(layer.feature.properties.id === cableId && layer.feature.properties.active) { layer.setStyle({ color: '#f97316', weight: 8, opacity: 1 }); layer.bindTooltip(name, { sticky: true, className: 'bg-white border border-slate-300 text-[10px] font-bold px-2 py-1 shadow-md' }).openTooltip(); } }); }
        function resetPathSegment(cableId) { pathLayer.eachLayer(layer => { if(layer.feature.properties.id === cableId && layer.feature.properties.active) { layer.setStyle({ color: layer.feature.properties.color, weight: 6, opacity: 1 }); layer.unbindTooltip(); } }); }
        function zoomToPathSegment(cableId) { const bounds = L.latLngBounds([]); pathLayer.eachLayer(layer => { if(layer.feature.properties.id === cableId) bounds.extend(layer.getBounds()); }); if(bounds.isValid()) map.fitBounds(bounds, { padding: [100, 100] }); }

        function resetPath() {
            // Clear map layers
            pathLayer.clearLayers();
            endpointLayer.clearLayers();

            // Reset in-memory path/solution state
            foundPaths = [];
            solutionSets = [];
            currentSolutionIndex = 0;
            currentPathIndex = 0;

            // Hide summary card
            document.getElementById('pathSummaryCard').classList.add('hidden');

            // Hide and clear the floating solution selector
            const solSelector = document.getElementById('solutionSelector');
            const solBtns = document.getElementById('solutionBtns');
            const solCount = document.getElementById('solutionCount');
            if (solSelector) {
                solSelector.classList.add('hidden');
                solSelector.classList.remove('flex');
            }
            if (solBtns) solBtns.innerHTML = '';
            if (solCount) solCount.innerText = '0';

            // Hide and clear the small path buttons above the map
            const pathBtnBar = document.getElementById('pathSelectorBtns');
            if (pathBtnBar) {
                pathBtnBar.classList.add('hidden');
                pathBtnBar.innerHTML = '';
            }

            // Clear the sidebar results panel
            const resultsArea = document.getElementById('resultsArea');
            const resultsList = document.getElementById('pathResultsList');
            if (resultsArea) resultsArea.classList.add('hidden');
            if (resultsList) resultsList.innerHTML = '';

            // Clear basic endpoint inputs (single/diverse/ring)
            const startEl = document.getElementById('pathStart');
            const endEl = document.getElementById('pathEnd');
            if (startEl) startEl.value = '';
            if (endEl) endEl.value = '';
            let idx = 0;
            while (document.getElementById(`stop${idx}`)) {
                document.getElementById(`stop${idx}`).value = '';
                idx++;
            }

            // Clear max distance
            const maxDistEl = document.getElementById('maxDist');
            if (maxDistEl) maxDistEl.value = '';

            // Rebuild dynamic inputs & constraints UI so all per-leg
            // include/avoid fields are cleared as well
            if (typeof handleModeChange === 'function') {
                handleModeChange();
            }
        }

        /* --- Main Render Function --- */
        function renderSolutionSelector(timeArg) { 
            const container = document.getElementById('solutionBtns'); 
            const selector = document.getElementById('solutionSelector'); 
            const countBadge = document.getElementById('solutionCount');

            if(solutionSets.length > 0) {
                // Show the panel
                selector.classList.remove('hidden'); 
                selector.classList.add('flex');
                
                // [NEW] Auto-expand panel so user sees the new results immediately
                expandRoutesPanel();

                // Update the count badge
                countBadge.innerText = solutionSets.length;

                // [NEW] Time display in header
                let timeHtml = '';
                if(timeArg) {
                    timeHtml = `<div class="px-3 pb-2 text-[9px] font-mono text-slate-400 text-right border-b border-slate-100 dark:border-slate-800 bg-slate-50/50 dark:bg-slate-900">
                        Calculation: <span class="font-bold text-brand-600">${timeArg}s</span>
                    </div>`;
                }
                
                // Generate the list of solution cards
                const listHtml = solutionSets.map((sol, i) => { 
                    const isActive = i === currentSolutionIndex;
                    
                    // Build key-value details if they exist
                    const details = sol.details ? sol.details.map(d => 
                        `<div><span class="text-slate-400">${d.k}:</span> <span class="${d.c||'text-slate-600 dark:text-slate-300'}">${d.v}</span></div>`
                    ).join('') : '';

                    return `
                        <button
                            onclick="switchSolution(${i})"
                            onmouseover="previewSolution(${i})"
                            onmouseout="endSolutionPreview()"
                            class="option-card-btn group border border-slate-300 rounded-xl p-2 hover:border-blue-300 transition-all shadow-sm ${isActive ? 'active' : ''} ${sol.isError ? 'error' : ''}">
                            
                            <div class="flex items-center justify-between w-full">
                                <span class="font-bold text-[11px] leading-none">${sol.label.split('<')[0]}</span>
                                ${sol.label.includes('<span') ? sol.label.substring(sol.label.indexOf('<span')) : ''}
                            </div>
                            
                            ${sol.meta ? `<div class="text-[9px] font-mono opacity-70 mt-1 mb-1.5 border-b border-dashed border-slate-200 pb-1 w-full">${sol.meta}</div>` : ''}
                            
                            ${sol.details ? `<div class="grid grid-cols-2 gap-x-2 gap-y-0.5 text-[9px] w-full font-medium opacity-90">${details}</div>` : ''}
                        </button>`;

                }).join('');

                // Inject content: Timer + List Buttons
                container.innerHTML = timeHtml + `<div class="flex flex-col space-y-3 pt-2">` + listHtml + `</div>`;
            } else {
                // Hide panel if no solutions
                selector.classList.add('hidden');
                selector.classList.remove('flex');
            }
        }

        function applySolution(idx) {
            const sol = solutionSets[idx];
            if (!sol) return;

            // When a solution is applied (initial trace or click), start in "show all legs" mode
            foundPaths = sol.paths || [];
            currentPathIndex = 0;
            highlightAllOnHover = true;      // all paths of this solution are active by default

            renderPathSelector();
            displayAllPathsOnMap();
            renderSidebarPathList();
        }

        function switchSolution(idx) {
            // Click = commit the solution, not just preview
            previewMode = false;
            // We want all legs of the chosen solution highlighted
            highlightAllOnHover = true;

            currentSolutionIndex = idx;
            renderSolutionSelector();
            applySolution(idx);
        }

        function previewSolution(idx) {
            // Hover preview â€“ do not change which card is marked active
            if (!solutionSets[idx]) return;

            previewMode = true;
            // On hover, always highlight all paths of that solution
            highlightAllOnHover = true;
            applySolution(idx);
        }

        function endSolutionPreview() {
            // Mouse left the solution card â€“ revert to the currently selected solution
            previewMode = false;
            // Do NOT reset highlightAllOnHover here so we keep the "all legs" view
            if (solutionSets[currentSolutionIndex]) {
                applySolution(currentSolutionIndex);
                renderSolutionSelector();
            }
        }

        function displayAllPathsOnMap() {
            pathLayer.clearLayers();
            const feats = [];

            const highlightAll = highlightAllOnHover;

            // Accumulate distance of all ACTIVE (highlighted) paths
            let totalMeters = 0;

            foundPaths.forEach((pathObj, pIdx) => {
                const isActivePath = highlightAll ? true : (pIdx === currentPathIndex);

                pathObj.segments.forEach((step, stepIdx) => {

                    // Distance accumulation only for active, non-broken segments
                    if (isActivePath && !step.isBroken) {
                        if (step.cableName && cableSegmentsByName[step.cableName]) {
                            totalMeters += cableSegmentsByName[step.cableName].reduce(
                                (s, c) => s + (parseFloat(c.properties.SPAN_LENGTH) || 0),
                                0
                            );
                        } else if (step.cost) {
                            totalMeters += step.cost;
                        }
                    }

                    if (step.geometry) {
                        feats.push({
                            type: "Feature",
                            properties: {
                                id: step.cableId || 'BROKEN',
                                violation: step.violation,
                                isBroken: step.isBroken,
                                color: pathObj.color,
                                pathIndex: pIdx,
                                active: isActivePath,
                                stepOrder: stepIdx
                            },
                            geometry: step.geometry
                        });
                    } else {
                        let geoms = [];
                        if (step.cableName && cableSegmentsByName[step.cableName]) geoms = cableSegmentsByName[step.cableName];
                        else if (step.cableId && cableSegmentsById[step.cableId]) geoms = cableSegmentsById[step.cableId];
                        else if (cableLookup[step.cableId]) geoms = [cableLookup[step.cableId]];

                        geoms.forEach(g => {
                            feats.push({
                                type: "Feature",
                                properties: {
                                    id: step.cableId,
                                    violation: step.violation,
                                    color: pathObj.color,
                                    pathIndex: pIdx,
                                    active: isActivePath,
                                    stepOrder: stepIdx
                                },
                                geometry: g.geometry
                            });
                        });
                    }
                });
            });

            pathLayer.addData({ type: "FeatureCollection", features: feats });

            // Update summary card based on what is actually highlighted on the map
            const summaryCard = document.getElementById('pathSummaryCard');
            const summaryDistanceEl = document.getElementById('summaryDistance');

            if (totalMeters > 0) {
                if (summaryDistanceEl) {
                    summaryDistanceEl.innerText = (totalMeters / 1000).toFixed(2);
                }
                if (summaryCard) {
                    summaryCard.classList.remove('hidden');
                }
            } else if (summaryCard) {
                summaryCard.classList.add('hidden');
            }

            // [NEW SECTION] Render Conflicts
            const currentSol = solutionSets[currentSolutionIndex];
            if (currentSol && currentSol.conflicts) {
                
                currentSol.conflicts.forEach(c => {
                    if (c.type === 'shared-cable') {
                        // Draw thick flashing red line for shared cables
                        L.geoJSON(c.geometry, {
                            style: { color: '#ff00ff', weight: 10, opacity: 0.6, dashArray: '5,10' },
                            className: 'animate-pulse' // Use Tailwind pulse if available or CSS animation
                        }).addTo(pathLayer).bindTooltip("SHARED CABLE", {permanent:true, className:'bg-red-600 text-white font-bold text-[10px] px-1'});
                    } 
                    else if (c.type === 'shared-node') {
                        // Draw warning icon for shared nodes
                        L.marker([c.lat, c.lng], {
                            icon: L.divIcon({
                                className: 'bg-transparent',
                                html: `<div class="w-6 h-6 bg-orange-500 rounded-full flex items-center justify-center text-white border-2 border-white shadow-lg animate-bounce"><i class="fa-solid fa-triangle-exclamation text-xs"></i></div>`
                            })
                        }).addTo(pathLayer).bindTooltip(`SHARED NODE: ${c.id}`, {offset:[0,-10]});
                    } 
                    else if (c.type === 'cross' || c.type === 'lead-cross') {
                        // Draw X marker for crossings
                        const color = c.type === 'lead-cross' ? 'bg-amber-500' : 'bg-purple-600';
                        L.marker([c.lat, c.lng], {
                            icon: L.divIcon({
                                className: 'bg-transparent',
                                html: `<div class="w-5 h-5 ${color} rounded-full flex items-center justify-center text-white border-2 border-white shadow-lg"><i class="fa-solid fa-xmark text-xs"></i></div>`
                            })
                        }).addTo(pathLayer).bindTooltip(c.type === 'lead-cross' ? "LEAD-IN CROSSING" : "CABLE CROSSING", {offset:[0,-10]});
                    }
                });
            }


            const bounds = pathLayer.getBounds();
            if (bounds && bounds.isValid()) {
                if (!previewMode) {
                    // Normal mode: always fit to the (active) solution
                    map.fitBounds(bounds, { padding: [50, 50] });
                } else {
                    // Hover preview: only recenter if the full solution is NOT already in view
                    const currentView = map.getBounds();
                    if (!currentView.contains(bounds)) {
                        map.fitBounds(bounds, { padding: [50, 50] });
                    }
                }
            }
        }

        function renderSidebarPathList() {
            const list = document.getElementById('pathResultsList');
            list.innerHTML = '';
            document.getElementById('resultsArea').classList.remove('hidden');

            if (!foundPaths[currentPathIndex]) return;
            const pathObj = foundPaths[currentPathIndex];

            document.getElementById('resultsTitle').innerHTML = pathObj.label;
            document.getElementById('resultsCount').innerText = pathObj.segments.length + " Segments";

            pathObj.segments.forEach((step, i) => {
                if (step.isBroken) {
                    list.innerHTML += `
                        <div class="p-3 bg-red-50 dark:bg-red-900/20 border-b border-red-100 dark:border-red-800">
                            <div class="flex items-center gap-2 text-red-600 font-bold text-[11px]">
                                <i class="fa-solid fa-circle-xmark"></i> Connectivity Failed
                            </div>
                            <div class="text-[9px] text-red-500 mt-1">
                                No valid path found between endpoints using current constraints.
                            </div>
                        </div>`;
                    return;
                }

                const cName = step.cableName || step.cableId;
                const from = spliceLookup[step.from]?.properties?.NAME || step.from;
                const to = spliceLookup[step.target]?.properties?.NAME || step.target;
                const len = Math.round(step.cost);

                list.innerHTML += `
                    <div class="p-3 bg-white dark:bg-slate-800 border-b border-slate-100 dark:border-slate-800
                                hover:bg-slate-50 dark:hover:bg-slate-700 transition cursor-pointer group"
                        onmouseover="highlightPathSegment('${step.cableId}', '${cName}')"
                        onmouseout="resetPathSegment('${step.cableId}')"
                        onclick="zoomToPathSegment('${step.cableId}')">
                        <div class="flex justify-between items-center mb-1">
                            <span class="font-bold text-[11px] text-brand-700 dark:text-brand-400 group-hover:underline">
                                ${i + 1}. ${cName}
                            </span>
                            <span class="text-[9px] font-mono bg-slate-100 dark:bg-slate-700 px-1.5 py-0.5 rounded text-slate-600">
                                ${len}m
                            </span>
                        </div>
                        <div class="flex items-center gap-2 text-[9px] text-slate-500">
                            <span class="truncate max-w-[45%]">${from}</span>
                            <i class="fa-solid fa-arrow-right text-slate-300"></i>
                            <span class="truncate max-w-[45%]">${to}</span>
                        </div>
                    </div>`;
            });

            // Total distance now comes from displayAllPathsOnMap(), based on highlighted paths
        }


        function renderPathSelector() {
            const container = document.getElementById('pathSelectorBtns');

            if (foundPaths.length > 0) {
                container.classList.remove('hidden');
                container.innerHTML = foundPaths.map((p, i) => {
                    return `
                        <button
                            onclick="switchPath(${i})"
                            class="path-btn px-3 py-1.5 rounded-lg text-[11px] font-bold transition flex items-center gap-1.5 ${i === currentPathIndex ? 'active' : ''}">
                            <span class="w-2.5 h-2.5 rounded-full shadow-sm" style="background:${p.color}"></span>
                            ${p.label}
                        </button>`;
                }).join('');
            } else {
                container.classList.add('hidden');
            }
        }

        function switchPath(index) {
            // User wants to focus on a single leg/path
            previewMode = false;
            highlightAllOnHover = false;   // only the selected path is active

            currentPathIndex = index;
            renderPathSelector();
            displayAllPathsOnMap();
            renderSidebarPathList();
        }

        function getPathStyle(f) { const isActive = f.properties.active; const isBroken = f.properties.isBroken; if(isBroken) return { color: '#ef4444', weight: 4, opacity: 1, dashArray: '8,8', className: 'broken-leg-dash' }; const w = isActive ? 6 : 4; const o = isActive ? 1.0 : 0.4; const c = f.properties.violation ? '#ef4444' : f.properties.color; const d = f.properties.violation ? '5,5' : null; return { color: c, weight: w, opacity: o, dashArray: d, className: isActive ? 'path-highlight' : 'path-dimmed' }; }

        class BinaryHeap{constructor(e){this.content=[],this.scoreFunction=e}push(e){this.content.push(e),this.bubbleUp(this.content.length-1)}pop(){var e=this.content[0],t=this.content.pop();return this.content.length>0&&(this.content[0]=t,this.sinkDown(0)),e}size(){return this.content.length}bubbleUp(e){for(var t=this.content[e],n=this.scoreFunction(t);e>0;){var r=Math.floor((e+1)/2)-1,o=this.content[r];if(n>=this.scoreFunction(o))break;this.content[r]=t,this.content[e]=o,e=r}}sinkDown(e){for(var t=this.content.length,n=this.content[e],r=this.scoreFunction(n);;){var o=2*(e+1),i=o-1,s=null;if(i<t){var a=this.content[i],c=this.scoreFunction(a);c<r&&(s=i)}if(o<t){var l=this.content[o],u=this.scoreFunction(l);u<(null==s?r:c)&&(s=o)}if(null==s)break;this.content[e]=this.content[s],this.content[s]=n,e=s}}}
        document.getElementById('searchInput').addEventListener('input', () => { clearTimeout(searchTimeout); searchTimeout = setTimeout(renderSidebar, 300); });


        // --- GUIDE / TOUR LOGIC ---

        const tourSteps = [
            { targetId: 'tour-upload', title: 'Data Ingestion', desc: 'Start by uploading your network files here.', position: 'bottom-left' },
            { targetId: 'btn-state', title: 'Region Filtering', desc: 'Filter which states to display on map.', position: 'bottom-right' },
            { targetId: 'tab-browser-btn', title: 'Asset Browser', desc: 'Browse and search for Sites, Splices, or Cables in the list view.', position: 'right', action: () => switchTab('browser') },
            { targetId: 'tab-pathfinder-btn', title: 'Pathfinder Tools', desc: 'Switch to Path Finding Engine.', position: 'right', action: () => switchTab('pathfinder') },
            { targetId: 'tour-modes', title: 'Routing Mode', desc: 'Select Single, Diverse, or Ring Path Finding Mode.', position: 'right', action: () => switchTab('pathfinder') },
            { 
                targetId: 'tour-avoid', 
                title: 'Specific Constraints', 
                desc: 'Expand to include/exclude specific Cables or Splices.', 
                position: 'right', 
                action: () => switchTab('pathfinder'),
                forceScrollBottom: true // NEW: Forces scroll to reveal this area fully
            },
            { 
                targetId: 'tour-sim', 
                title: 'Path Similarity', 
                desc: 'Control how unique found routes must be.', 
                position: 'right', 
                action: () => switchTab('pathfinder'),
                forceScrollBottom: true
            },
            { 
                targetId: 'tour-prefs', 
                title: 'Global Preferences', 
                desc: 'Set soft preferences and max distances.', 
                position: 'right', 
                action: () => switchTab('pathfinder'),
                forceScrollBottom: true
            },
            { 
                targetId: 'btn-calculate', 
                title: 'Run Calculation', 
                desc: 'Click to calculate optimal routes.', 
                position: 'top', 
                action: () => switchTab('pathfinder'),
                forceScrollBottom: true
            }
        ];

        /* --- UPDATED TOUR LOGIC --- */

        /* --- UPDATED TOUR LOGIC (Spotlight Method) --- */

        let tourIndex = 0;

        function startTour() {
            tourIndex = 0;
            const spot = document.getElementById('tour-spotlight');
            spot.classList.remove('hidden');
            requestAnimationFrame(() => spot.classList.remove('opacity-0'));
            renderTourStep();
        }

        function endTour() {
            const spot = document.getElementById('tour-spotlight');
            const tip = document.getElementById('tour-tooltip');
            spot.classList.add('opacity-0');
            tip.classList.add('hidden', 'opacity-0');
            setTimeout(() => spot.classList.add('hidden'), 300);
        }

        function nextStep() {
            if (tourIndex < tourSteps.length - 1) {
                tourIndex++;
                renderTourStep();
            } else {
                endTour();
            }
        }

        // NEW: Previous Step Function
        function prevStep() {
            if (tourIndex > 0) {
                tourIndex--;
                renderTourStep();
            }
        }

        function renderTourStep() {
            const step = tourSteps[tourIndex];
            const tooltip = document.getElementById('tour-tooltip');
            const spot = document.getElementById('tour-spotlight');

            if (step.action) step.action();

            // 1. Handle Special Scroll Requirement
            // We scroll the CONTAINER div, not just the window
            if (step.forceScrollBottom) {
                // Select the specific scrollable area inside the pathfinder inputs
                const container = document.querySelector('#pathfinderInputs .overflow-y-auto');
                if (container) {
                    container.scrollTo({ top: container.scrollHeight, behavior: 'smooth' });
                }
            }

            // 2. Wait briefly for scroll/UI to settle
            setTimeout(() => {
                const target = document.getElementById(step.targetId);
                if (!target) return;

                // âœ… Only auto-centre when we are NOT forcing the container to bottom.
                // For forceScrollBottom steps, this was undoing the bottom scroll.
                if (!step.forceScrollBottom) {
                    target.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }

                const rect = target.getBoundingClientRect();

                // Move Spotlight
                spot.style.top = (rect.top - 4) + 'px';
                spot.style.left = (rect.left - 4) + 'px';
                spot.style.width = (rect.width + 8) + 'px';
                spot.style.height = (rect.height + 8) + 'px';

                // Update Tooltip
                document.getElementById('tour-title').innerText = step.title;
                document.getElementById('tour-desc').innerText = step.desc;
                document.getElementById('tour-progress').innerText = `${tourIndex + 1} / ${tourSteps.length}`;

                tooltip.classList.remove('hidden');

                const tipRect = tooltip.getBoundingClientRect();
                let top, left;

                if (step.position === 'bottom-left') {
                    top = rect.bottom + 16; left = rect.left;
                } else if (step.position === 'bottom-right') {
                    top = rect.bottom + 16; left = rect.right - tipRect.width;
                } else if (step.position === 'top') {
                    top = rect.top - tipRect.height - 16; left = rect.left + (rect.width / 2) - (tipRect.width / 2);
                } else if (step.position === 'right') {
                    top = rect.top + (rect.height / 2) - (tipRect.height / 2); left = rect.right + 16;
                } else {
                    top = rect.bottom + 16; left = rect.left;
                }

                // Boundary Guards
                if (left + tipRect.width > window.innerWidth) left = window.innerWidth - tipRect.width - 20;
                if (top + tipRect.height > window.innerHeight) top = window.innerHeight - tipRect.height - 20;
                if (left < 10) left = 10;
                if (top < 10) top = 10;

                tooltip.style.top = `${top}px`;
                tooltip.style.left = `${left}px`;
                tooltip.style.opacity = '1';
                tooltip.style.transform = 'translateY(0)';
            }, 200);
        }

    </script>
</body>
</html>